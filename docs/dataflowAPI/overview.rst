.. _`sec:dataflow-intro`:

.. cpp:namespace:: Dyninst::DataflowAPI

DataflowAPI
###########

DataflowAPI aggregates a collection of dataflow analysis algorithms that
are useful in Dyninst development into a single library. These
algorithms can also be foundations for users to build customized
analyses. Currently, these algorithms include:

Slicing
  :ref:`Slicing <sec:slicing.h>` takes a program location as input and can either slice
  backward to determine which instructions affect the results of the
  given program location, or slice forward to determine which
  instructions are affected by the results of the given program
  location. One key feature of our slicing implementation is that users
  can control where and when to stop slicing through a set of callback
  functions.

Stack Analysis
  :ref:`Stack Analysis <sec:stackanalysis.h>` determines if a register or memory
  location points to the stack. If it does point to the stack, Stack
  Analysis may be able to determine the exact stack location that is
  pointed to.

Symbolic Expansion and Evaluation
  :ref:`Symbolic Expansion and Evaluation <sec:SymEval.h>` converts an instruction
  into several symbolic expressions. Each symbolic expression represents the overall
  effects of these instructions on a register or a memory location.
  :cpp:class:`SymEval` provides interfaces for expanding an instruction to its
  symbolic expression and expanding a slice graph to symbolic expressions
  for all abstract locations defined in this slice.

Register Liveness
  :ref:`Register Liveness <sec:liveness.h>` determines if a register is live or not at a
  program location. A register is live at a program location if it will
  be used later in the program before its content is overwritten.

.. _`sec:dataflow-abstractions`:

Abstractions
************

DataflowAPI starts from the control flow graphs generated by ParseAPI
and the instructions generated by InstructionAPI. From these, it
provides dataflow facts in a variety of forms. The key abstractions used
by DataflowAPI are:

Abstract Location
  An :cpp:class:`Abstract Location <Absloc>` represents a register or memory location in the
  program. DataflowAPI provides three types of abstract locations:
  register, stack, and heap. A register abstract location represents a
  register, and the same register at two different program locations is
  treated as the same abstract location. A stack abstract location
  consists of the stack frame to which it belongs and the offset within
  the stack frame. A heap abstract location consists of the virtual
  address of the heap variable.

Abstract Region
  An :cpp:class:`Abstract Region <AbsRegion>` a set of abstract locations of the same
  type. If an abstract region contains only a single abstract location,
  the abstract location is precisely represented. If an abstract region
  contains more than one abstract location, the region contains the
  type of the locations. In the cases where it represents memory
  (either heap or stack), an abstract region also contains the memory
  address calculation that gives rise to this region. See
  :cpp:class:`AbsRegion` for details.

Abstract Syntax Tree
  An :cpp:class:`Abstract Syntax Tree <Dyninst::AST>` (AST) represents a symbolic expression of an
  instruction’s semantics. Specifically, an AST specifies how the value
  of an abstract location is modified by the instruction.

Assignment
  An :cpp:class:`Assignment` represents a single data dependency of abstract
  regions in an instruction. For example, ``xchg eax, ebx`` creates two
  assignments: one from pre-instruction ``eax`` to post-instruction
  ``ebx``, and one from pre-instruction ``ebx`` to post-instruction
  ``eax``.

Stack Height
  :ref:`Stack Height <sec:stackanalysis.h>` represents the difference between a value
  in an abstract location and the stack pointer at a function’s call site. See
  :cpp:class:`StackAnalysis::Height` for details.

.. _`sec:dataflow-usage`:

Usage
*****

  We show several examples of how to use DataflowAPI. In these examples,
  we assume that the mutatee has been parsed and we have function and
  block objects to analyze. Users may refer to the ParseAPI manual for how
  to obtain these function and block objects.

Slicing
=======

  The following example uses DataflowAPI to perform a backward slice on an
  indirect jump instruction to determine the instructions that affect the
  calculation of the jump target. The goal of this example is to show

    1) how to convert an instruction to assignments
    2) how to perform slicing on a given assignment
    3) how to extend the default :cpp:class:`Slicer::Predicates` and write call back functions to
       control the behavior of slicing.

.. rli:: https://raw.githubusercontent.com/dyninst/examples/master/dataflowAPI/slicing.cpp
   :language: cpp
   :linenos:

Symbolic Evaluation
===================

  The following example shows how to expand a slice to ASTs and analyze an
  AST. Suppose we have a slice representing the instructions that affect
  the jump target of an indirect jump instruction. We can get the
  expression of the jump targets and visit the expression to see if it is
  a constant.

.. rli:: https://raw.githubusercontent.com/dyninst/examples/master/dataflowAPI/symbolic_evaluation.cpp
   :language: cpp
   :linenos:

Liveness Analysis
=================

  The following example shows how to query for live registers.

.. rli:: https://raw.githubusercontent.com/dyninst/examples/master/dataflowAPI/liveness.cpp
   :language: cpp
   :linenos:


Stack Analysis
==============

  The following example shows how to use stack analysis to print out all
  defined stack heights at the first instruction in a block.

.. rli:: https://raw.githubusercontent.com/dyninst/examples/master/dataflowAPI/stack_analysis.cpp
   :language: cpp
   :linenos:
