framestepper.h
==============

.. cpp:namespace:: Dyninst::stackwalk

Class FrameStepper
~~~~~~~~~~~~~~~~~~

**Defined in:** ``framestepper.h``

The ``FrameStepper`` class is an interface that tells StackwalkerAPI how
to walk through a specific type of stack frame. There may be many
different ways of walking through a stack frame on a platform, e.g, on
Linux/x86 there are different mechanisms for walking through system
calls, signal handlers, regular functions, and frameless functions. A
single ``FrameStepper`` describes how to walk through one of these types
of stack frames.

A user can create their own ``FrameStepper`` classes that tell
StackwalkerAPI how to walk through new types of stack frames. A new
``FrameStepper`` object must be added to a ``StepperGroup`` before it
can be used.

In addition to walking through individual stack frames, a
``FrameStepper`` tells its ``StepperGroup`` when it can be used. The
``FrameStepper`` registers address ranges that cover objects in the
target process’ code space (such as functions). These address ranges
should contain the objects that will create stack frames through which
the ``FrameStepper`` can walk. If multiple ``FrameStepper`` objects have
overlapping address ranges, then a priority value is used to determine
which ``FrameStepper`` should be attempted first.

``FrameStepper`` is an interface class; it cannot be instantiated. Users
who want to develop new ``FrameStepper`` objects should inherit from
this class and implement the the desired virtual functions. The
``getCallerFrame, getPriority``, and ``getName`` functions must be
implemented; all others may be overridden if desired.

.. code-block:: cpp

    typedef enum gcf_success, gcf_stackbottom, gcf_not_me, gcf_error gcframe_ret_t
    virtual gcframe_ret_t getCallerFrame(const Frame &in, Frame &out) = 0

This method walks through a single stack frame and generates a Frame
object that represents the caller’s stack frame. Parameter in will be a
Frame object that this FrameStepper is capable of walking through.
Parameter out is an output parameter that this method should set to the
Frame object that called in.

There may be multiple ways of walking through a different types of stack
frames. Each ``FrameStepper`` class should be able to walk through a
type of stack frame. For example, on x86 one ``FrameStepper`` could be
used to walk through stack frames generated by ABI-compliant functions;
out’s FP and RA are found by reading from in’s FP, and out’s SP is set
to the word below in’s FP. A different ``FrameStepper`` might be used to
walk through stack frames created by functions that have optimized away
their FP. In this case, in may have a FP that does not point out’s FP
and RA. The ``FrameStepper`` will need to use other mechanisms to
discover out’s FP or RA; perhaps the ``FrameStepper`` searches through
the stack for the RA or performs analysis on the function that created
the stack frame.

If ``getCallerFrame`` successfully walks through in, it is required to
set the following parameters in out. See
Section `3.3.2 <#subsec:frame>`__ for more details on the values that
can be set in a Frame object:

Return Address (RA)
   The RA should be set with the ``Frame::setRA`` method.

Stack Pointer (SP)
   The SP should be set with the ``Frame::setSP`` method.

Frame Pointer (FP)
   The FP should be set with the ``Frame::setFP`` method

Optionally, getCallerFrame can also set any of following parameters in
out:

Return Address Location (RALocation)
   The RALocation should be set with the ``Frame::setRALocation()``
   method.

Stack Pointer Location (SPLocation)
   The SPLocation should be set with the ``Frame::setRALocation()``
   method.

Frame Pointer Location (FPLocation)
   The FPLocation should be set with the ``Frame::setFPLocation()``
   method.

If a location field in out is not set, then the appropriate
``Frame::getRALocation``, ``Frame::getSPLocation`` or
``Frame::getFPLocation`` method will return ``loc_unknown``.

``getCallerFrame`` should return ``gcf_success`` if it successfully
walks through in and creates an ``out`` ``Frame`` object. It should
return ``gcf_stackbottom`` if in is the bottom of the stack and there
are no stack frames below it. It should return ``gcf_not_me`` if in is
not the correct type of stack frame for this ``FrameStepper`` to walk
through. StackwalkerAPI will then attempt to locate another
``FrameStepper`` to handle ``in`` or abort the stackwalk. It should
return ``gcf_error`` if there was an error and the stack walk should be
aborted.

.. code-block:: cpp

    virtual void registerStepperGroup(StepperGroup *steppergroup)

This method is used to notify a ``FrameStepper`` when StackwalkerAPI
adds it to a ``StepperGroup``. The ``StepperGroup`` to which this
``FrameStepper`` is being added is passed in parameter steppergroup.
This method can be used to initialize the ``FrameStepper`` (in addition
to any ``FrameStepper`` constructor).

.. code-block:: cpp

    virtual unsigned getPriority() const = 0

This method is used by the ``StepperGroup`` to decide which
``FrameStepper`` to use if multiple ``FrameStepper`` objects are
registered over the same address range (see addAddressRanges in
Section `3.6.3 <#subsec:steppergroup>`__ for more information about
address ranges). This method returns an integer representing a priority
level, the lower the number the higher the priority.

The default ``FrameStepper`` objects provided by StackwalkerAPI all
return priorities between ``0x1000`` and ``0x2000``. If two
``FrameStepper`` objects have an overlapping address range, and they
have the same priority, then the order in which they are used is
undefined.

.. code-block:: cpp

    FrameStepper(Walker *w);

Constructor definition for all ``FrameStepper`` instances.

.. code-block:: cpp

    virtual ProcessState *getProcessState();

Return the ``ProcessState`` used by the ``FrameStepper``. Can be
overridden if the user desires.

.. code-block:: cpp

    virtual Walker *getWalker();

Return the ``Walker`` associated with the ``FrameStepper``. Can be
overridden if the user desires.

.. code-block:: cpp

    typedef std::pair<std::string, Address> LibAddrPair; typedef enum
    library_load, library_unload lib_change_t; virtual void
    newLibraryNotification(LibAddrPair *libAddr, lib_change_t change);

This function is called when a new library is loaded by the process; it
should be implemented if the ``FrameStepper`` requires such information.

.. code-block:: cpp

    virtual const char *getName() const = 0;

Returns a name for the ``FrameStepper``; must be implemented by the
user.

FrameSteppers
-------------

StackwalkerAPI ships with numerous default implementations of the
``FrameStepper`` class. Each of these ``FrameStepper`` implementations
allow StackwalkerAPI to walk a type of call frames.
Section `3.6.1 <#subsec:defaults>`__ describes which ``FrameStepper``
implementations are available on which platforms. This sections gives a
brief description of what each ``FrameStepper`` implementation does.
Each of the following classes implements the ``FrameStepper`` interface
described in Section `3.6.2 <#subsec:framestepper>`__, so we do not
repeat the API description for the classes here.

Several of the ``FrameStepper``\ s use helper classes (see
``FrameFuncStepper`` as an example). Users can further customize the
behavior of a ``FrameStepper`` by providing their own implementation of
these helper classes.

Class FrameFuncStepper
~~~~~~~~~~~~~~~~~~~~~~

This class implements stack walking through a call frame that is setup
with the architectures standard stack frame. For example, on x86 this
``FrameStepper`` will be used to walk through stack frames that are
setup with a ``push %ebp/mov %esp,%ebp`` prologue.

Class FrameFuncHelper
~~~~~~~~~~~~~~~~~~~~~

``FrameFuncStepper`` uses a helper class, ``FrameFuncHelper``, to get
information on what kind of stack frame it’s walking through. The
``FrameFuncHelper`` will generally use techniques such as binary
analysis to determine what type of stack frame the ``FrameFuncStepper``
is walking through. Users can have StackwalkerAPI use their own binary
analysis mechanisms by providing an implementation of this
``FrameFuncHelper``.

There are two important types used by ``FrameFuncHelper`` and one
important function: typedef enum unknown_t=0, no_frame, standard_frame,
savefp_only_frame, frame_type;

The ``frame_type`` describes what kind of stack frame a function uses.
If it does not set up a stack frame then ``frame_type`` should be
``no_frame``. If it sets up a standard frame then ``frame_type`` should
be ``standard_frame``. The ``savefp_only_frame`` value currently only
has meaning on the x86 family of systems, and means that a function
saves the old frame pointer, but does not setup a new frame pointer (it
has a ``push %ebp`` instruction, but no ``mov %esp,%ebp``). If the
``FrameFuncHelper`` cannot determine the ``frame_type``, then it should
be assigned the value ``unknown_t``.

.. code-block:: cpp

    typedef enum unknown_s=0, unset_frame, halfset_frame, set_frame frame_state;

The ``frame_state`` type determines the current state of function with a
stack frame at some point of execution. For example, a function may set
up a standard stack frame and have a ``frame_type`` of
``standard_frame``, but execution may be at the first instruction in the
function and the frame is not yet setup, in which case the
``frame_state`` will be ``unset_frame``.

If the function sets up a standard stack frame and the execution point
is someplace where the frame is completely setup, then the
``frame_state`` should be ``set_frame``. If the function sets up a
standard frame and the execution point is at a point where the frame
does not yet exist or has been torn down, then ``frame_state`` should be
``unset_frame``. The ``halfset_frame`` value of ``frame_state`` is
currently only meaningful on the x86 family of architecture, and should
if the function has saved the old frame pointer, but not yet set up a
new frame pointer.

.. code-block:: cpp

    typedef std::pair<frame_type, frame_state> alloc_frame_t; virtual alloc_frame_t allocatesFrame(Address addr) = 0;

The ``allocatesFrame`` function of ``FrameFuncHelper`` returns a
``alloc_frame_t`` that describes the frame_type of the function at
``addr`` and the ``frame_state`` of the function when execution reached
``addr``.

If ``addr`` is invalid or an error occurs, allocatedFrame should return
``alloc_frame_t(unknown_t, unknown_s)``.

Class SigHandlerStepper
~~~~~~~~~~~~~~~~~~~~~~~

The ``SigHandlerStepper`` is used to walk through UNIX signal handlers
as found on the call stack. On some systems a signal handler generates a
special kind of stack frame that cannot be walked through using normal
stack walking techniques.

Class DebugStepper
~~~~~~~~~~~~~~~~~~

This class uses debug information found in a binary to walk through a
stack frame. It depends on SymtabAPI to read debug information from a
binary, then uses that debug information to walk through a call frame.

Most binaries must be built with debug information (``-g`` with ``gcc``)
in order to include debug information that this ``FrameStepper`` uses.
Some languages, such as C++, automatically include stackwalking debug
information for use by exceptions. The ``DebugStepper`` class will also
make use of this kind of exception information if it is available.

Class AnalysisStepper
~~~~~~~~~~~~~~~~~~~~~

This class uses dataflow analysis to determine possible stack sizes at
all locations in a function as well as the location of the frame
pointer. It is able to handle optimized code with omitted frame pointers
and overlapping code sequences.

Class StepperWanderer
~~~~~~~~~~~~~~~~~~~~~

This class uses a heuristic approach to find possible return addresses
in the stack frame. If a return address is found that matches a valid
caller of the current function, we conclude it is the actual return
address and construct a matching stack frame. Since this approach is
heuristic it can make mistakes leading to incorrect stack information.
It has primarily been replaced by the ``AnalysisStepper`` described
above.

Class BottomOfStackStepper
~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``BottomOfStackStepper`` doesn’t actually walk through any type of
call frame. Instead it attempts to detect whether the bottom of the call
stack has been reached. If so, ``BottomOfStackStepper`` will report
``gcf_stackbottom`` from its ``getCallerFrame`` method. Otherwise it
will report ``gcf_not_me``. ``BottomOfStackStepper`` runs with a higher
priority than any other ``FrameStepper`` class.
