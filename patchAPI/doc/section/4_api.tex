\section{API Reference}
\label{sec-api}

This section describes functions in PatchAPI. The API is organized as a
collection of C++ classes. The classes in PatchAPI fall under the C++ namespace
Dyninst::PatchAPI. To access them, programmers should refer to them using the
``Dyninst::PatchAPI::'' prefix, e.g., Dyninst::PatchAPI::Point. Alternatively,
programmers can add the C++ \emph{using} keyword above any references to PatchAPI
objects, e.g.,\emph{using namespace Dyninst::PatchAPI} or \emph{using Dyninst::PatchAPI::Point}.

Most classes in PatchAPI use boost shared pointer (\emph{boost::shared\_ptr<T>}) for
memory management, where we typedef a class's shared pointer by appending the
Ptr to the class name, e.g., PatchMgrPtr for PatchMgr.

\subsection{Public Interface}
\label{sec-3.1}

\subsubsection{PatchMgr}
\label{sec-3.1.1}

\textbf{Declared in}: PatchMgr.h

The PatchMgr class is the top-level class for finding instrumentation \textbf{Points},
inserting or deleting \textbf{Snippets}, and registering user-provided plugins.


\begin{apient}
static PatchMgrPtr create(AddrSpacePtr as, PointMakerPtr pf = PointMakerPtr(new PointMaker),
                          InstrumenterPtr inst = InstrumenterPtr());
\end{apient}


\apidesc{
This factory method creates a new PatchMgr object that performs binary code
patching. It takes input three plugins, including AddrSpace \emph{as}, PointMaker
\emph{pf}, and Instrumenter \emph{inst}. PatchAPI uses default plugins for PointMaker and
Instrumenter, if \emph{pf} and \emph{inst} are not specified.

This method returns PatchMgrPtr() if it was unable to create a new PatchMgr
object.
}

\begin{apient}
Point *findPoint(Location loc, Point::Type type, bool create = true);

\end{apient}

\apidesc{
This method returns a unique Point according to a Location \emph{loc} and a Type
\emph{type}. If we cannot find a Point, this method returns NULL. PatchAPI creates
Points on demand, so if a Point is not yet created, and the \emph{create} parameter
is false, this method returns NULL.
}

\begin{apient}
template <class OutputIterator>
bool findPoint(Location loc, Point::Type type, OutputIterator outputIter,
               bool create = true);
\end{apient}

\apidesc{
This method finds a Point at a physical Location \emph{loc} with a \emph{type}.  It adds
the found Point to \emph{outputIter} that is a STL inserter.

This method returns true if a point is found, or the \emph{create} parameter is
false; otherwise, it returns false.
}

\begin{apient}
template <class OutputIterator>
bool findPoints(Location loc, Point::Type types, OutputIterator outputIter,
                bool create = true);
\end{apient}

\apidesc{
This method finds Points at a physical Location \emph{loc} with composite \emph{types}
that are combined using the overloaded operator ``|''. This function outputs
Points to the STL inserter \emph{outputIter}.

This method returns true if a point is found, or the \emph{create} parameter is
false; otherwise, it returns false.
}

\begin{apient}
template <class FilterFunc,
          class FilterArgument,
          class OutputIterator>
bool findPoints(Location loc, Point::Type types, FilterFunc filter_func,
                FilterArgument filter_arg, OutputIterator outputIter, bool create = true);
\end{apient}

\apidesc{
This method finds Points at a physical Location \emph{loc} with composite \emph{types}
that are combined using the overloaded operator ``|''. Then, this method applies a
filter functor \emph{filter\_func} with an argument \emph{filter\_arg} on each found Point.
The method outputs Points to the inserter \emph{outputIter}.

If no any Point is created, then this method returns false; otherwise, true is
returned. The code below shows the prototype of an example functor.
}

\lstset{language=[GNU]C++,basicstyle=\fontfamily{fvm}\selectfont\small}
\lstset{numbers=none}
\begin{lstlisting}
template <class T>
class FilterFunc {
  public:
    bool operator()(Point::Type type, Location loc, T arg) {
      // The logic to check whether this point is what we need
      return true;
    }
};
\end{lstlisting}

\apidesc{
In the functor FilterFunc above, programmers check each candidate Point by
looking at the Point::Type, Location, and the user-specified parameter \emph{arg}.
If the return value is true, then the Point being checked will be put in the STL
inserter \emph{outputIter}; otherwise, this Point will be discarded.
}

\begin{apient}
struct Scope {
  Scope(PatchBlock *b);
  Scope(PatchFunction *f, PatchBlock *b);
  Scope(PatchFunction *f);
};
\end{apient}

\apidesc{ The Scope structure specifies the scope to find points, where a scope
  could be a function, or a basic block. This is quite useful if programmers
  don't know the exact Location, then they can use Scope as a wildcard. A basic
  block can be contained in multiple functions. The second constructor only
  specifies the block \emph{b} in a particular function \emph{f}.}

\begin{apient}
template <class FilterFunc,
          class FilterArgument,
          class OutputIterator>
bool findPoints(Scope scope, Point::Type types, FilterFunc filter_func,
                FilterArgument filter_arg, OutputIterator output_iter, bool create = true);
\end{apient}

\apidesc{
This method finds points in a \emph{scope} with certain \emph{types} that are combined
together by using the overloaded operator ``|''. Then, this method applies the
filter functor \emph{filter\_func} on each found Point. It outputs Points where
\emph{filter\_func} returns true to the STL inserter \emph{output\_iter}.

If no any Point is created, then this function returns false; otherwise, true is
returned.
}


\begin{apient}
template <class OutputIterator>
bool findPoints(Scope scope, Point::Type types, OutputIterator output_iter, bool create = true);
\end{apient}

\apidesc{
This method finds points in a \emph{scope} with certain \emph{types} that are combined
together by using the overloaded operator ``|''. It outputs the found points to
the STL inserter \emph{output\_iter}.

If no any Point is created, then this method returns false; otherwise, true is
returned.
}

\begin{apient}
bool removeSnippet(InstancePtr);
\end{apient}

\apidesc{
This method removes a snippet Instance.

It returns false if the point associated with this Instance cannot be found;
otherwise, true is returned.
}

\begin{apient}
template <class FilterFunc,
          class FilterArgument>
bool removeSnippets(Scope scope, Point::Type types, FilterFunc filter_func,
                    FilterArgument filter_arg);
\end{apient}

\apidesc{
This method deletes ALL snippet instances at certain points in certain \emph{scope}
with certain \emph{types}, and those points pass the test of \emph{filter\_func}.

If no any point can be found, this method returns false; otherwise, true is
returned.
}

\begin{apient}
bool removeSnippets(Scope scope, Point::Type types);
\end{apient}

\apidesc{
This method deletes ALL snippet instances at certain points in certain \emph{scope}
with certain \emph{types}.
}

\begin{apient}
void destroy(Point *point);
\end{apient}

\apidesc{
This method is to destroy the specified \emph{point}.
}

\begin{apient}
AddrSpacePtr as() const;
PointMakerPtr pointMaker() const;
InstrumenterPtr instrumenter() const;
\end{apient}

\apidesc{
The above three functions return the corresponding plugin: AddrSpace,
PointMaker, Instrumenter.
}

\subsubsection{Point}
\label{sec-3.1.2}

\textbf{Declared in}: Point.h

The Point class is in essence a container of a list of snippet
instances. Therefore, the Point class has methods similar to those in STL.

\begin{apient}
struct Location {
   static Location Function(PatchFunction *f);
   static Location Block(PatchBlock *b);
   static Location BlockInstance(PatchFunction *f, PatchBlock *b, bool trusted = false);
   static Location Edge(PatchEdge *e);
   static Location EdgeInstance(PatchFunction *f, PatchEdge *e);
   static Location Instruction(PatchBlock *b, Address a);
   static Location InstructionInstance(PatchFunction *f, PatchBlock *b, Address a);
   static Location InstructionInstance(PatchFunction *f, PatchBlock *b, Address a,
                                       InstructionAPI::Instruction::Ptr i,
                                       bool trusted = false);
   static Location EntrySite(PatchFunction *f, PatchBlock *b, bool trusted = false);
   static Location CallSite(PatchFunction *f, PatchBlock *b);
   static Location ExitSite(PatchFunction *f, PatchBlock *b);
};
\end{apient}

\apidesc{ The Location structure uniquely identifies the physical location of a
  point.  A Location object plus a Point::Type value uniquely identifies a
  point, because multiple Points with different types can exist at the same
  physical location.  The Location structure provides a set of static functions
  to create an object of Location, where each function takes the corresponding
  CFG structures to identify a physical location. In addition, some functions
  above (e.g., InstructionInstance) takes input the \emph{trusted} parameter
  that is to indicate PatchAPI whether the CFG structures passed in is
  trusted. If the \emph{trusted} parameter is false, then PatchAPI would have
  additional checking to verify the CFG structures passed by users, which causes
  non-trivial overhead.}


\begin{apient}
enum Point::Type {
  PreInsn,
  PostInsn,
  BlockEntry,
  BlockExit,
  BlockDuring,
  FuncEntry,
  FuncExit,
  FuncDuring,
  EdgeDuring,
  PreCall,
  PostCall,
  OtherPoint,
  None,
  InsnTypes = PreInsn | PostInsn,
  BlockTypes = BlockEntry | BlockExit | BlockDuring,
  FuncTypes = FuncEntry | FuncExit | FuncDuring,
  EdgeTypes = EdgeDuring,
  CallTypes = PreCall | PostCall
};
\end{apient}

\apidesc{ The enum Point::Type specifies the logical point type. Multiple enum
  values can be OR-ed to form a composite type. For example, the composite type
  of ``PreCall | BlockEntry | FuncExit'' is to specify a set of points with the
  type PreCall, or BlockEntry, or FuncExit.}

\begin{apient}
instance_iter begin();
instance_iter end();
\end{apient}

\apidesc{

The method begin() returns an iterator pointing to the beginning of the
container storing snippet Instances, while the method end() returns an iterator
pointing to the end of the container (past the last element).
}

\begin{apient}
InstancePtr pushBack(SnippetPtr);
InstancePtr pushFront(SnippetPtr);
\end{apient}


\apidesc{

Multiple instances can be inserted at the same Point. We maintain the instances
in an ordered list. The pushBack method is to push the specified Snippet to the
end of the list, while the pushFront method is to push to the front of the
list.

Both methods return the Instance that uniquely identifies the inserted snippet.
}

\begin{apient}
bool remove(InstancePtr instance);
\end{apient}


\apidesc{
This method removes the given snippet \emph{instance} from this Point.
}

\begin{apient}
void clear();
\end{apient}


\apidesc{
This method removes all snippet instances inserted to this Point.
}

\begin{apient}
size_t size();
\end{apient}


\apidesc{
Returns the number of snippet instances inserted at this Point.
}

\begin{apient}
Address address() const;
\end{apient}


\apidesc{
Returns the address associated with this point, if it has one; otherwise, it
returns 0.
}

\begin{apient}
Type type() const;
\end{apient}


\apidesc{
Returns the Point type of this point.
}

\begin{apient}
bool empty() const;
\end{apient}


\apidesc{
Indicates whether the container of instances at this Point is empty or not.
}

\begin{apient}
PatchFunction* getCallee();
\end{apient}


\apidesc{
Returns the function that is invoked at this Point, which should have
Point::Type of Point::PreCall or Point::PostCall. It there is not a function
invoked at this point, it returns NULL.
}

\begin{apient}
const PatchObject* obj() const;
\end{apient}


\apidesc{
Returns the PatchObject where the Point resides.
}

\begin{apient}
const InstructionAPI::Instruction::Ptr insn() const;
\end{apient}


\apidesc{
Returns the Instruction where the Point resides.
}

\begin{apient}
PatchFunction* getFunction() const;
\end{apient}


\apidesc{
Returns the function where the Point resides.
}

\begin{apient}
PatchBlock* getBlock() const;
\end{apient}


\apidesc{
Returns the PatchBlock where the Point resides.
}

\begin{apient}
PatchEdge* getEdge() const;
\end{apient}


\apidesc{
Returns the Edge where the Point resides.
}

\begin{apient}
PatchCallback *cb() const;
\end{apient}


\apidesc{
Returns the PatchCallback object that is associated with this Point.
}

\begin{apient}
static bool TestType(Point::Type types, Point::Type type);
\end{apient}


\apidesc{
This static method tests whether a set of \emph{types} contains a specific \emph{type}.
}

\begin{apient}
static void AddType(Point::Type& types, Point::Type type);
\end{apient}


\apidesc{
This static method adds a specific \emph{type} to a set of \emph{types}.
}

\begin{apient}
static void RemoveType(Point::Type& types, Point::Type trg);
\end{apient}


\apidesc{
This static method removes a specific \emph{type} from a set of \emph{types}.
}

\subsubsection{Instance}
\label{sec-3.1.3}

\textbf{Declared in}: Point.h

The Instance class is a representation of a particular snippet inserted at a
particular point. If a Snippet is inserted to N points or to the same point for
N times (N $>$ 1), then there will be N Instances.


\begin{apient}
bool destroy();
\end{apient}


\apidesc{
This method destroys the snippet Instance itself.
}

\begin{apient}
Point* point() const;
\end{apient}


\apidesc{
Returns the Point where the Instance is inserted.
}

\begin{apient}
SnippetPtr snippet() const;
\end{apient}


\apidesc{
Returns the Snippet. Please note that, the same Snippet may have multiple
instances inserted at different Points or the same Point.
}

\subsection{Plugin Interface}
\label{sec-3.2}

\subsubsection{AddrSpace}
\label{sec-3.2.1}

\textbf{Declared in}: AddrSpace.h

The AddrSpace class represents the address space of a \textbf{Mutatee}, where it
contains a collection of \textbf{PatchObjects} that represent shared libraries or a
binary executable. In addition, programmers implement some memory management
interfaces in the AddrSpace class to determines the type of the code patching -
1st party, 3rd party, or binary rewriting.


\begin{apient}
virtual bool write(PatchObject* obj, Address to, Address from, size_t size);
\end{apient}


\apidesc{

This method copies \emph{size}-byte data stored at the address \emph{from} on the
\textbf{Mutator} side to the address \emph{to} on the \textbf{Mutatee} side. The parameter \emph{to} is
the relative offset for the PatchObject \emph{obj}, if the instrumentation is for
binary rewriting; otherwise \emph{to} is an absolute address.

If the write operation succeeds, this method returns true; otherwise, false.
}

\begin{apient}
virtual Address malloc(PatchObject* obj, size_t size, Address near);
\end{apient}


\apidesc{
This method allocates a buffer of \emph{size} bytes on the \textbf{Mutatee} side. The
address \emph{near} is a relative address in the object \emph{obj}, if the instrumentation
is for binary rewriting; otherwise, \emph{near} is an absolute address, where this
method tries to allocates a buffer near the address \emph{near}.

If this method succeeds, it returns a non-zero address; otherwise, it returns 0.
}

\begin{apient}
virtual Address realloc(PatchObject* obj, Address orig, size_t size);
\end{apient}


\apidesc{
This method reallocates a buffer of \emph{size} bytes on the \textbf{Mutatee} side. The
original buffer is at the address \emph{orig}. This method tries to reallocate the
buffer near the address \emph{orig}, where \emph{orig} is a relative address in the
PatchObject \emph{obj} if the instrumentation is for binary rewriting; otherwise,
\emph{orig} is an absolute address.

If this method succeeds, it returns a non-zero address; otherwise, it returns 0.
}

\begin{apient}
virtual bool free(PatchObject* obj, Address orig);
\end{apient}


\apidesc{
This method deallocates a buffer on the \textbf{Mutatee} side at the address \emph{orig}.
If the instrumentation is for binary rewriting, then the parameter \emph{orig} is a
relative address in the object \emph{obj}; otherwise, \emph{orig} is an absolute address.

If this method succeeds, it returns true; otherwise, it returns false.
}

\begin{apient}
virtual bool loadObject(PatchObject* obj);
\end{apient}


\apidesc{
This method loads a PatchObject into the address space. If this method succeeds, it
returns true; otherwise, it returns false.
}

\begin{apient}
typedef std::set<PatchObject*> AddrSpace::ObjSet;

ObjSet& objSet();
\end{apient}


\apidesc{
Returns a set of PatchObjects.
}

\begin{apient}
PatchObject* getFirstObject();
\end{apient}


\apidesc{
Returns the PatchObject of the executable of the \textbf{Mutatee}.
}

\begin{apient}
PatchMgrPtr mgr();
\end{apient}


\apidesc{
Returns the PatchMgr's pointer, where the PatchMgr contains this address space.
}

\subsubsection{Snippet}
\label{sec-3.2.2}

\textbf{Declared in}: Snippet.h

The Snippet class is a template class, so that programmers can easily plug in
their own snippet representation and the corresponding mini-compiler to
translate the representation into the binary code.


\begin{apient}
template <class T>
class Snippet;

\end{apient}


\apidesc{
The template parameter T is the implementation of the Snippet.
}

\begin{apient}
static Ptr create(T rep);
\end{apient}


\apidesc{
Creates an object of the Snippet. It takes input of the actual representation of
a snippet, which is a user-defined structure.
}

\begin{apient}
static Ptr get(SnippetPtr s);
\end{apient}


\apidesc{
This static method does type-casting. The parameter \emph{s} is the return value of
Instance::snippet().

This method returns an object of this class.
}

\begin{apient}
T rep();
\end{apient}


\apidesc{
Returns the implementation of this Snippet.
}

\subsubsection{Command}
\label{sec-3.2.3}

\textbf{Declared in}: Command.h

The Command class represents an instrumentation request (e.g., snippet insertion
or removal), or an internal logical step in the code patching (e.g., install
instrumentation).


\begin{apient}
virtual bool run() = 0;
\end{apient}


\apidesc{
Executes the normal operation of this Command.

It returns true on success; otherwise, it returns false.
}

\begin{apient}
virtual bool undo() = 0;
\end{apient}


\apidesc{
Undoes the operation of this Command.
}

\begin{apient}
virtual bool commit();
\end{apient}


\apidesc{
Implements the transactional semantics: all succeed, or all fail. Basically, it
performs such logic:
}

\lstset{language=[GNU]C++,basicstyle=\fontfamily{fvm}\selectfont\small}
\lstset{numbers=none}
\begin{lstlisting}
if (run()) {
  return true;
} else {
  undo();
  return false;
}
\end{lstlisting}

\subsubsection{BatchCommand}
\label{sec-3.2.4}

\textbf{Declared in}: Command.h

The BatchCommand class inherits from the Command class. It is actually a
container of a list of Commands that will be executed in a transaction: all
Commands will succeed, or all will fail.


\begin{apient}
typedef std::list<CommandPtr> CommandList;

CommandList to_do_;
CommandList done_;
\end{apient}


\apidesc{
This class has two protected members \emph{to\_do\_} and \emph{done\_}, where \emph{to\_do\_}
is a list of Commands to execute, and \emph{done\_} is a list of Commands that are
executed.
}

\begin{apient}
virtual bool run();
virtual bool undo();
\end{apient}

\apidesc{
The method run() of BatchCommand invokes the run() method of each Command in
\emph{to\_do\_} in order, and puts the finished Commands in \emph{done\_}. The method
undo() of BatchCommand invokes the undo() method of each Command in \emph{undo\_} in
order.
}

\begin{apient}
void add(CommandPtr command);
\end{apient}


\apidesc{
This method adds a Command into \emph{to\_do\_}.
}

\begin{apient}
void remove(CommandList::iterator iter);
\end{apient}

\apidesc{
This method removes a Command from \emph{to\_do\_}.
}

\subsubsection{Instrumenter}
\label{sec-3.2.5}

\textbf{Declared in}: Command.h

The Instrumenter class inherits BatchCommand to encapsulate the core code
patching logic, which includes binary code generation. Instrumenter would
contain several logical steps that are individual Commands.


\begin{apient}
CommandList user_commands_;
\end{apient}


\apidesc{
This class has a protected data member \emph{user\_commands\_} that contains all
Commands issued by users, e.g., snippet insertion. This is to facilitate the
implementation of the instrumentation engine.
}

\begin{apient}
static InstrumenterPtr create(AddrSpacePtr as);
\end{apient}

\apidesc{
Returns an instance of Instrumenter, and it takes input the address space \emph{as}
that is going to be instrumented.
}

\begin{apient}
virtual bool replaceFunction(PatchFunction* oldfunc, PatchFunction* newfunc);
\end{apient}


\apidesc{
Replaces a function \emph{oldfunc} with a new function \emph{newfunc}.

It returns true on success; otherwise, it returns false.
}

\begin{apient}
virtual bool revertReplacedFunction(PatchFunction* oldfunc);
\end{apient}

\apidesc{
Undoes the function replacement for \emph{oldfunc}.

It returns true on success; otherwise, it returns false.
}

\begin{apient}
typedef std::map<PatchFunction*, PatchFunction*> FuncModMap;
\end{apient}

\apidesc{
The type FuncModMap contains mappings from an PatchFunction to another
PatchFunction.
}

\begin{apient}
virtual FuncModMap& funcRepMap();
\end{apient}

\apidesc{
Returns the FuncModMap that contains a set of mappings from an old function to a
new function, where the old function is replaced by the new function.
}

\begin{apient}
virtual bool wrapFunction(PatchFunction* oldfunc, PatchFunction* newfunc, Symbol *clone);
\end{apient}


\apidesc{
Replaces all calls to \emph{oldfunc} with calls to wrapper \emph{newfunc} (similar to
function replacement). However, we create a copy of original using the name
information contained in clone that can be used to call the original. The
wrapper code would look like follows:
}

\lstset{language=[GNU]C++,basicstyle=\fontfamily{fvm}\selectfont\small}
\lstset{numbers=none}
\begin{lstlisting}
void *malloc_wrapper(int size) {
  // do stuff
  void *ret = malloc_clone(size);
  // do more stuff
  return ret;
}
\end{lstlisting}


\apidesc{
This interface requires the user to give us a name (as represented by clone) for
the original function. This matches current techniques and allows users to use
indirect calls (function pointers). We use a Symbol, rather than a string, to
ensure that we name the clone correctly; this also helps with mangled names in
C++ contexts.
}

\begin{apient}
virtual bool revertWrappedFunction(PatchFunction* oldfunc);
\end{apient}

\apidesc{
Undoes the function wrapping for \emph{oldfunc}.

It returns true on success; otherwise, it returns false.
}

\begin{apient}
virtual FuncModMap& funcWrapMap();

\end{apient}


\apidesc{
The type FuncModMap contains mappings from the original PatchFunction to the
wrapper PatchFunction.
}

\begin{apient}
bool modifyCall(PatchBlock *callBlock, PatchFunction *newCallee, PatchFunction *context = NULL);
\end{apient}


\apidesc{
Replaces the function that is invoked in the basic block \emph{callBlock} with the
function \emph{newCallee}. There may be multiple functions containing the same
\emph{callBlock}, so the \emph{context} parameter specifies in which function the
\emph{callBlock} should be modified. If \emph{context} is NULL, then the \emph{callBlock} would
be modified in all PatchFunctions that contain it. If the \emph{newCallee} is NULL,
then the \emph{callBlock} is removed.

It returns true on success; otherwise, it returns false.
}

\begin{apient}
bool revertModifiedCall(PatchBlock *callBlock, PatchFunction *context = NULL);
\end{apient}


\apidesc{
Undoes the function call modification for \emph{oldfunc}. There may be multiple
functions containing the same \emph{callBlock}, so the \emph{context} parameter specifies
in which function the \emph{callBlock} should be modified. If \emph{context} is NULL, then
the \emph{callBlock} would be modified in all PatchFunctions that contain it.

It returns true on success; otherwise, it returns false.
}

\begin{apient}
bool removeCall(PatchBlock *callBlock, PatchFunction *context = NULL);
\end{apient}


\apidesc{
Removes the \emph{callBlock}, where a function is invoked. There may be multiple
functions containing the same \emph{callBlock}, so the \emph{context} parameter specifies
in which function the \emph{callBlock} should be modified. If \emph{context} is NULL, then
the \emph{callBlock} would be modified in all PatchFunctions that contain it.

It returns true on success; otherwise, it returns false.
}


\begin{apient}
typedef map<PatchBlock*,        // B  : A call block
            map<PatchFunction*, // F_c: Function context
                PatchFunction*> // F  : The function to be replaced
           > CallModMap;
\end{apient}


\apidesc{

The type CallModMap maps from B -> F$_c$ -> F, where B identifies a call block,
and F$_c$ identifies an (optional) function context for the replacement. If F$_c$ is
not specified, we use NULL. F specifies the replacement callee; if we want to
remove the call entirely, we use NULL.
}

\begin{apient}
CallModMap& callModMap();
\end{apient}


\apidesc{
Returns the CallModMap for function call replacement / removal.
}

\begin{apient}
AddrSpacePtr as() const;
\end{apient}


\apidesc{
Returns the address space associated with this Instrumenter.
}

\subsubsection{Patcher}
\label{sec-3.2.6}

\textbf{Declared in}: Command.h

The class Patcher inherits from the class BatchCommand. It accepts
instrumentation requests from users, where these instrumentation requests are
Commands (e.g., snippet insertion). Furthermore, Patcher implicitly adds an
instance of Instrumenter to the end of the Command list to generate binary code
and install the instrumentation.


\begin{apient}
Patcher(PatchMgrPtr mgr)
\end{apient}


\apidesc{
The constructor of Patcher takes input the relevant PatchMgr \emph{mgr}.
}

\begin{apient}
virtual bool run();
\end{apient}


\apidesc{
Performs the same logic as BatchCommand::run(), except that this function
implicitly adds an internal Command -- Instrumenter, which is executed after all
other Commands in the \emph{to\_do\_}.
}

\subsubsection{PatchCallback}
\label{sec-3.2.7}

\textbf{Declared in}: PatchCallback.h

PatchAPI has a CFG layer (PatchObject, PatchFunction, PatchBlock, and PatchEdge)
that is used to specify instrumentation and modification. Programmers may extend
this CFG by deriving their own classes, or annotate it with their own data. To
inform programmers when the CFG changes we provide a callback interface as the
event handler for events like basic block creation, basic block split, or
function destroying.


\begin{apient}
virtual void destroy_cb(PatchBlock *);
virtual void destroy_cb(PatchEdge *);
virtual void destroy_cb(PatchFunction *);
virtual void destroy_cb(PatchObject *);
\end{apient}


\apidesc{
Programmers implement the above virtual methods to handle the event of
destroying a PatchBlock, a PatchEdge, a PatchFunction, or a PatchObject
respectively. All the above methods will be called before the events trigger.
}

\begin{apient}
virtual void create_cb(PatchBlock *);
virtual void create_cb(PatchEdge *);
virtual void create_cb(PatchFunction *);
virtual void create_cb(PatchObject *);
\end{apient}


\apidesc{

Programmers implement the above virtual methods to handle the event of creating
a PatchBlock, a PatchEdge, a PatchFunction, or a PatchObject respectively. All
the above methods will be called after the events trigger.
}

\begin{apient}
virtual void split_block_cb(PatchBlock *first, PatchBlock *second);
\end{apient}


\apidesc{

Programmers implement the above virtual method to handle the event of splitting
a PatchBlock. The above method will be called after the event triggers.
}

\begin{apient}
virtual void remove_edge_cb(PatchBlock *, PatchEdge *, edge_type_t);
virtual void add_edge_cb(PatchBlock *, PatchEdge *, edge_type_t);

\end{apient}


\apidesc{
Programmers implement the above virtual methods to handle the events of removing
or adding an PatchEdge respectively. The method remove\_edge\_cb will be called
before the event triggers, while the method add\_edge\_cb will be called after
the event triggers.
}

\begin{apient}
virtual void remove_block_cb(PatchFunction *, PatchBlock *);
virtual void add_block_cb(PatchFunction *, PatchBlock *);
\end{apient}


\apidesc{
Programmers implement the above virtual methods to handle the events of removing
or adding a PatchBlock respectively. The method remove\_block\_cb will be called
before the event triggers, while the method add\_block\_cb will be called after
the event triggers.
}

\begin{apient}
virtual void create_cb(Point *pt);
virtual void destroy_cb(Point *pt);
\end{apient}


\apidesc{
Programmers implement the create\_cb method above, which will be called after
the Point \emph{pt} is created. And, programmers implement the destroy\_cb method,
which will be called before the point \emph{pt} is deleted.
}

\begin{apient}
virtual void change_cb(Point *pt, PatchBlock *first, PatchBlock *second);
\end{apient}


\apidesc{
Programmers implement this method, which is to be invoked after a block is
split. The Point \emph{pt} may belong to either the \emph{first} PatchBlock or the
\emph{second} PatchBlock.
}

\subsubsection{PatchObject}
\label{sec-3.2.8}

\textbf{Declared in}: PatchObject.h

The PatchObject class is a wrapper of ParseAPI's CodeObject class (has-a), which
represents an individual binary code object, such as an executable or a library.


\begin{apient}
static PatchObject* create(ParseAPI::CodeObject* co, Address base,
                           CFGMakerPtr cm = CFGMakerPtr(new CFGMaker),
                           PatchCallback *cb = NULL);
\end{apient}


\apidesc{
Creates an instance of PatchObject, which has \emph{co} as its on-disk representation
(ParseAPI::CodeObject), and \emph{base} as the base address where this object is
loaded in the memory. For binary rewriting, base should be 0. The \emph{cm} and \emph{cb}
parameters are for registering plugins.
}

\begin{apient}
static PatchObject* clone(PatchObject* par_obj, Address base, PatchCallback *cb);
\end{apient}


\apidesc{
Returns a new object that is copied from the specified object \emph{par\_obj} at the
loaded address \emph{base}. The parameter \emph{cb} is for registering the PatchCallback
plugin.
}

\begin{apient}
Address codeBase();
\end{apient}


\apidesc{
Returns the base address where this object is loaded in memory.
}

\begin{apient}
PatchFunction *getFunc(ParseAPI::Function *func, bool create = true);
\end{apient}


\apidesc{
Returns an instance of PatchFunction in this object, according to the \emph{func}
parameter. PatchAPI creates a PatchFunction on-demand, so if there is not any
PatchFunction created for the ParseAPI function \emph{func}, and the \emph{create}
parameter is false, then no any instance of PatchFunction will be created.

It returns NULL in two cases. First, the function \emph{func} is not in this
PatchObject. Second, the PatchFunction is not yet created and the \emph{create} is
false. Otherwise, it returns a PatchFunction.
}

\begin{apient}
template <class Iter>
void funcs(Iter iter);
\end{apient}

\apidesc{
Outputs all instances of PatchFunction in this PatchObject to the STL inserter
\emph{iter}.
}

\begin{apient}
PatchBlock *getBlock(ParseAPI::Block* blk, bool create = true);
\end{apient}


\apidesc{
Returns an instance of PatchBlock in this object, according to the \emph{blk}
parameter. PatchAPI creates a PatchBlock on-demand, so if there is not any
PatchBlock created for the ParseAPI block \emph{blk}, and the \emph{create} parameter is
false, then no any instance of PatchBlock will be created.

It returns NULL in two cases. First, the ParseAPI block \emph{blk} is not in this
PatchObject. Second, the PatchBlock is not yet created and the \emph{create} is
false. Otherwise, it returns a PatchBlock.
}

\begin{apient}
template <class Iter>
void blocks(Iter iter);
\end{apient}

\apidesc{
Outputs all instances of PatchBlock in this object to the STL inserter \emph{iter}.
}

\begin{apient}
PatchEdge *getEdge(ParseAPI::Edge* edge, PatchBlock* src, PatchBlock* trg, bool create = true);
\end{apient}


\apidesc{
Returns an instance of PatchEdge in this object, according to the parameters
ParseAPI::Edge \emph{edge}, source PatchBlock \emph{src}, and target PatchBlock
\emph{trg}. PatchAPI creates a PatchEdge on-demand, so if there is not any PatchEdge
created for the ParseAPI \emph{edge}, and the \emph{create} parameter is false, then no
any instance of PatchEdge will be created.

It returns NULL in two cases. First, the ParseAPI \emph{edge} is not in this
PatchObject. Second, the PatchEdge is not yet created and the \emph{create} is
false. Otherwise, it returns a PatchEdge.
}

\begin{apient}
template <class Iter>
void edges(Iter iter);
\end{apient}


\apidesc{
Outputs all instances of PatchEdge in this object to the STL inserter \emph{iter}.
}

\begin{apient}
PatchCallback *cb() const;
\end{apient}


\apidesc{
Returns the PatchCallback object associated with this PatchObject.
}

\subsubsection{PatchFunction}
\label{sec-3.2.9}

\textbf{Declared in}: PatchCFG.h

The PatchFunction class is a wrapper of ParseAPI's Function class (has-a), which
represents a function.


\begin{apient}
const string &name();
\end{apient}


\apidesc{
Returns the function's mangled name.
}

\begin{apient}
Address addr() const;
\end{apient}


\apidesc{
Returns the address of the first instruction in this function.
}

\begin{apient}
ParseAPI::Function *function();
\end{apient}



\apidesc{
Returns the ParseAPI::Function associated with this PatchFunction.
}

\begin{apient}
PatchObject* object();
\end{apient}

\apidesc{
Returns the PatchObject associated with this PatchFunction.
}

\begin{apient}
typedef std::set<PatchBlock *> PatchFunction::blockset;

const blockset &blocks();
\end{apient}


\apidesc{
Returns a set of all PatchBlocks in this PatchFunction.
}

\begin{apient}
PatchBlock *entry();
\end{apient}


\apidesc{
Returns the entry block of this PatchFunction.
}

\begin{apient}
const blockset &exits();
\end{apient}


\apidesc{
Returns a set of exit blocks of this PatchFunction.
}

\begin{apient}
const blockset &calls();
\end{apient}


\apidesc{
Returns a set of all call blocks of this PatchFunction.
}

\begin{apient}
PatchCallback *cb() const;
\end{apient}

\apidesc{
Returns the PatchCallback object associated with this PatchFunction.
}

\subsubsection{PatchBlock}
\label{sec-3.2.10}

\textbf{Declared in}: PatchCFG.h

The PatchBlock class is a wrapper of ParseAPI's Block class (has-a), which
represents a basic block.


\begin{apient}
Address start() const;
\end{apient}


\apidesc{
Returns the lower bound of this block (the address of the first instruction).
}

\begin{apient}
Address end() const;
\end{apient}


\apidesc{
Returns the upper bound (open) of this block (the address immediately following
the last byte in the last instruction).
}

\begin{apient}
Address last() const;
\end{apient}


\apidesc{
Returns the address of the last instruction in this block.
}

\begin{apient}
Address size() const;
\end{apient}


\apidesc{
Returns end() - start().
}

\begin{apient}
bool isShared();
\end{apient}


\apidesc{
Indicates whether this block is contained by multiple functions.
}

\begin{apient}
int containingFuncs() const;
\end{apient}

\apidesc{
Returns the number of functions that contain this block.
}

\begin{apient}
void getInsns(Insns &insns) const;
\end{apient}


\apidesc{
This function outputs Instructions that are in this block to \emph{insns}.
}

\begin{apient}
InstructionAPI::Instruction::Ptr getInsn(Address a) const;
\end{apient}


\apidesc{
Returns an Instruction that has the address \emph{a} as its starting address. If no
any instruction can be found in this block with the starting address \emph{a}, it
returns InstructionAPI::Instruction::Ptr().
}

\begin{apient}
std::string disassemble() const;
\end{apient}


\apidesc{
Returns a string containing the disassembled code for this block. This is mainly
for debugging purpose.
}

\begin{apient}
bool containsCall();
\end{apient}


\apidesc{
Indicates whether this PatchBlock contains a function call instruction.
}

\begin{apient}
bool containsDynamicCall();
\end{apient}

\apidesc{
Indicates whether this PatchBlock contains any indirect function call, e.g., via
function pointer.
}

\begin{apient}
PatchFunction* getCallee();
\end{apient}

\apidesc{
Returns the callee function, if this PatchBlock contains a function call;
otherwise, NULL is returned.
}

\begin{apient}
PatchFunction *function() const;
\end{apient}

\apidesc{
Returns a PatchFunction that contains this PatchBlock. If there are multiple
PatchFunctions containing this PatchBlock, then a random one of them is
returned.
}

\begin{apient}
ParseAPI::Block *block() const;
\end{apient}


\apidesc{
Returns the ParseAPI::Block associated with this PatchBlock.
}

\begin{apient}
PatchObject* object() const;
\end{apient}

\apidesc{
Returns the PatchObject that contains this block.
}

\begin{apient}
typedef std::vector<PatchEdge*> PatchBlock::edgelist;

const edgelist &sources();
\end{apient}

\apidesc{
Returns a list of the source PatchEdges. This PatchBlock is the target block of
the returned edges.
}

\begin{apient}
const edgelist &targets();
\end{apient}

\apidesc{
Returns a list of the target PatchEdges. This PatchBlock is the source block of
the returned edges.
}

\begin{apient}
template <class OutputIterator>
void getFunctions(OutputIterator result);
\end{apient}

\apidesc{
Outputs all functions containing this PatchBlock to the STL inserter \emph{result}.
}

\begin{apient}
PatchCallback *cb() const;
\end{apient}

\apidesc{
Returns the PatchCallback object associated with this PatchBlock.
}

\subsubsection{PatchEdge}
\label{sec-3.2.11}

\textbf{Declared in}: PatchCFG.h

The PatchEdge class is a wrapper of ParseAPI's Edge class (has-a), which joins
two PatchBlocks in the CFG, indicating the type of control flow transfer
instruction that joins the basic blocks to each other.


\begin{apient}
ParseAPI::Edge *edge() const;
\end{apient}

\apidesc{
Returns a ParseAPI::Edge associated with this PatchEdge.
}

\begin{apient}
PatchBlock *source();
\end{apient}

\apidesc{
Returns the source PatchBlock.
}

\begin{apient}
PatchBlock *target();
\end{apient}

\apidesc{
Returns the target PatchBlock.
}

\begin{apient}
ParseAPI::EdgeTypeEnum type() const;
\end{apient}

\apidesc{
Returns the edge type (ParseAPI::EdgeTypeEnum, please see \href{ftp://ftp.cs.wisc.edu/paradyn/releases/release7.0/doc/parseapi.pdf}{ParseAPI Manual}).
}

\begin{apient}
bool sinkEdge() const;
\end{apient}

\apidesc{
Indicates whether this edge targets the special sink block, where a sink block
is a block to which all unresolvable control ï¬‚ow instructions will be
linked.
}

\begin{apient}
bool interproc() const;
\end{apient}

\apidesc{
Indicates whether the edge should be interpreted as interprocedural (e.g.,
calls, returns, direct branches under certain circumstances).
}

\begin{apient}
void destroy(Point *pt);
\end{apient}

\apidesc{
Destroys a Point associated with this block.
}

\begin{apient}
PatchCallback *cb() const;
\end{apient}

\apidesc{
Returns a Patchcallback object associated with this PatchEdge.
}

\subsubsection{CFGMaker}
\label{sec-3.2.12}

\textbf{Declared in}: CFGMaker.h

The CFGMaker class is a factory class that constructs the above CFG structures
(PatchFunction, PatchBlock, and PatchEdge). The methods in this class are used
by PatchObject. Programmers can extend PatchFunction, PatchBlock and PatchEdge
by annotating their own data, and then use this class to instantiate these CFG
structures.


\begin{apient}
virtual PatchFunction* makeFunction(ParseAPI::Function* func, PatchObject* obj);
virtual PatchFunction* copyFunction(PatchFunction* func, PatchObject* obj);

virtual PatchBlock* makeBlock(ParseAPI::Block* blk, PatchObject* obj);
virtual PatchBlock* copyBlock(PatchBlock* blk, PatchObject* obj);

virtual PatchEdge* makeEdge(ParseAPI::Edge* edge, PatchBlock* src,
                            PatchBlock* trg, PatchObject* obj);
virtual PatchEdge* copyEdge(PatchEdge* edge, PatchObject* obj);
\end{apient}

\apidesc{
Programmers implement the above virtual methods to instantiate a CFG structure
(either a PatchFunction, a PatchBlock, or a PatchEdge) or to copy (e.g., when
forking a new process).
}

\subsubsection{PointMaker}
\label{sec-3.2.13}

\textbf{Declared in}: Point.h

The PointMaker class is a factory class that constructs instances of the Point
class. The methods of the PointMaker class are invoked by PatchMgr's findPoint
methods. Programmers can extend the Point class, and then implement this class
to instantiate the subclasses of Point.


\begin{apient}
PointMaker(PatchMgrPtr mgr);
\end{apient}

\apidesc{
The constructor takes input the relevant PatchMgr \emph{mgr}.
}

\begin{apient}
virtual Point *createPoint(Location loc, Point::Type type);
\end{apient}

\apidesc{
Create a Point at a particular location \emph{loc}, with a particular \emph{type}. If the
point creation fails, it returns NULL; otherwise, it returns a new Point.
}

\subsection{Default Plugin}
\label{sec-3.3}

\subsubsection{PushFrontCommand and PushBackCommand}
\label{sec-3.3.1}

\textbf{Declared in}: Command.h

The class PushFrontCommand and the class PushBackCommand inherit from the
Command class. They are to insert a snippet to a point. A point maintains a
list of snippet instances. PushFrontCommand would add the new snippet instance
to the front of the list, while PushBackCommand would add to the end of the
list.


\begin{apient}
static Ptr create(Point* pt, SnippetPtr snip);
\end{apient}

\apidesc{
This static method creates an object of PushFrontCommand or PushBackCommand.
}

\begin{apient}
InstancePtr instance();
\end{apient}

\apidesc{
Returns a snippet instance that is inserted at the point.
}

\subsubsection{RemoveSnippetCommand}
\label{sec-3.3.2}

\textbf{Declared in}: Command.h

The class RemoveSnippetCommand inherits from the Command class. It is to delete
a snippet Instance.


\begin{apient}
static Ptr create(InstancePtr instance);
\end{apient}

\apidesc{
This static function creates an instance of RemoveSnippetCommand.
}

\subsubsection{RemoveCallCommand}
\label{sec-3.3.3}

\textbf{Declared in}: Command.h

The class RemoveCallCommand inherits from the class Command. It is to remove a
function call.


\begin{apient}
static Ptr create(PatchMgrPtr mgr, PatchBlock* call_block, PatchFunction* context = NULL);
\end{apient}


\apidesc{
This static method takes input the relevant PatchMgr \emph{mgr}, the \emph{call\_block}
that contains the function call to be removed, and the PatchFunction \emph{context}.
There may be multiple PatchFunctions containing the same \emph{call\_block}. If the
\emph{context} is NULL, then the \emph{call\_block} would be deleted from all
PatchFunctions that contains it; otherwise, the \emph{call\_block} would be deleted
only from the PatchFuncton \emph{context}.
}

\subsubsection{ReplaceCallCommand}
\label{sec-3.3.4}

\textbf{Declared in}: Command.h

The class ReplaceCallCommand inherits from the class Command. It is to replace a
function call with another function.


\begin{apient}
static Ptr create(PatchMgrPtr mgr, PatchBlock* call_block,
                  PatchFunction* new_callee, PatchFunction* context);
\end{apient}

\apidesc{
This Command replaces the \emph{call\_block} with the new PatchFunction
\emph{new\_callee}. There may be multiple functions containing the same
\emph{call\_block}, so the \emph{context} parameter specifies in which function the
\emph{call\_block} should be replaced. If \emph{context} is NULL, then the \emph{call\_block}
would be replaced in all PatchFunctions that contains it.
}

\subsubsection{ReplaceFuncCommand}
\label{sec-3.3.5}

\textbf{Declared in}: Command.h

The class ReplaceFuncCommand inherits from the class Command. It is to replace
an old function with the new one.


\begin{apient}
static Ptr create(PatchMgrPtr mgr, PatchFunction* old_func, PatchFunction* new_func);
\end{apient}

\apidesc{
This Command replaces the old PatchFunction \emph{old\_func} with the new
PatchFunction \emph{new\_func}.
}

\subsubsection{AddrSpace\_1st}
\label{sec-3.3.6}


TODO

\subsubsection{Instrumenter\_1st}
\label{sec-3.3.7}


TODO
