/*
 * See the dyninst/COPYRIGHT file for copyright information.
 *
 * We provide the Paradyn Tools (below described as "Paradyn")
 * on an AS IS basis, and do not warrant its validity or performance.
 * We reserve the right to update, modify, or discontinue this
 * software at any time.  We shall have no obligation to supply such
 * updates or modifications or any other form of support to you.
 *
 * By your use of Paradyn, you understand and agree that we (or any
 * other person or entity with proprietary rights in Paradyn) are
 * under no obligation to provide either maintenance services,
 * update services, notices of latent defects, or correction of
 * defects for Paradyn.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#ifndef _ARCH_RISCV64_H
#define _ARCH_RISCV64_H

#include <stdint.h>
#include <assert.h>
#include <vector>
#include <bitset>
class AddressSpace;

namespace NS_riscv64 {

/*
 * Define riscv64 instruction information.
 *
 */


// In RISC-V, instruction length can be a multiple of 2 bytes

// Standard RISC-V instructions (RVI, RVA, RVM, RVF, RVD, ...) are 4 bytes
using rvInsn_t = uint32_t;
constexpr int RISCV_INSN_SIZE = 4;
static_assert(sizeof(rvInsn_t) == RISCV_INSN_SIZE, "rvInst_t size mismatch");

// Compressed instructions (RVC) are 2 bytes
using rvcInsn_t = uint16_t;
constexpr int RISCVC_INSN_SIZE = 2;
static_assert(sizeof(rvcInsn_t) == RISCVC_INSN_SIZE, "rvcInsn_t size mismatch");

// The minimum instruction size is 2 bytes
using rvMinInsn_t = rvcInsn_t;
constexpr int RISCV_MIN_INSN_SIZE = RISCVC_INSN_SIZE;
static_assert(sizeof(rvMinInsn_t) == RISCV_MIN_INSN_SIZE, "rvMinInst_t size mismatch");

// The maximum instruction size is 4 bytes
using rvMaxInsn_t = rvInsn_t;
constexpr int RISCV_MAX_INSN_SIZE = RISCV_INSN_SIZE;
static_assert(sizeof(rvMaxInsn_t) == RISCV_MAX_INSN_SIZE, "rvMaxInsn_t size mismatch");

// The bits in the register is 64 bits
constexpr int RISCV_REG_SIZE = 8;
// The immediates in instructions varies.
// The maximum is 21 bits, which can be stored in a 32 bit integer
constexpr int RISCV_IMM_SIZE = 4;

// Raw register encoding used in RISC-V instruction encoding
// These values identify registers when decoding instructions
// They are also used to emit register encoding during codegen
constexpr int32_t GPR_X0     = 0;
constexpr int32_t GPR_X1     = 1;
constexpr int32_t GPR_X2     = 2;
constexpr int32_t GPR_X3     = 3;
constexpr int32_t GPR_X4     = 4;
constexpr int32_t GPR_X5     = 5;
constexpr int32_t GPR_X6     = 6;
constexpr int32_t GPR_X7     = 7;
constexpr int32_t GPR_X8     = 8;
constexpr int32_t GPR_X9     = 9;
constexpr int32_t GPR_X10    = 10;
constexpr int32_t GPR_X11    = 11;
constexpr int32_t GPR_X12    = 12;
constexpr int32_t GPR_X13    = 13;
constexpr int32_t GPR_X14    = 14;
constexpr int32_t GPR_X15    = 15;
constexpr int32_t GPR_X16    = 16;
constexpr int32_t GPR_X17    = 17;
constexpr int32_t GPR_X18    = 18;
constexpr int32_t GPR_X19    = 19;
constexpr int32_t GPR_X20    = 20;
constexpr int32_t GPR_X21    = 21;
constexpr int32_t GPR_X22    = 22;
constexpr int32_t GPR_X23    = 23;
constexpr int32_t GPR_X24    = 24;
constexpr int32_t GPR_X25    = 25;
constexpr int32_t GPR_X26    = 26;
constexpr int32_t GPR_X27    = 27;
constexpr int32_t GPR_X28    = 28;
constexpr int32_t GPR_X29    = 29;
constexpr int32_t GPR_X30    = 30;
constexpr int32_t GPR_X31    = 31;

constexpr int32_t GPR_ZERO   = 0;
constexpr int32_t GPR_RA     = 1;
constexpr int32_t GPR_SP     = 2;
constexpr int32_t GPR_GP     = 3;
constexpr int32_t GPR_TP     = 4;
constexpr int32_t GPR_T0     = 5;
constexpr int32_t GPR_T1     = 6;
constexpr int32_t GPR_T2     = 7;
constexpr int32_t GPR_S0     = 8;
constexpr int32_t GPR_FP     = 8;
constexpr int32_t GPR_S1     = 9;
constexpr int32_t GPR_A0     = 10;
constexpr int32_t GPR_A1     = 11;
constexpr int32_t GPR_A2     = 12;
constexpr int32_t GPR_A3     = 13;
constexpr int32_t GPR_A4     = 14;
constexpr int32_t GPR_A5     = 15;
constexpr int32_t GPR_A6     = 16;
constexpr int32_t GPR_A7     = 17;
constexpr int32_t GPR_S2     = 18;
constexpr int32_t GPR_S3     = 19;
constexpr int32_t GPR_S4     = 20;
constexpr int32_t GPR_S5     = 21;
constexpr int32_t GPR_S6     = 22;
constexpr int32_t GPR_S7     = 23;
constexpr int32_t GPR_S8     = 24;
constexpr int32_t GPR_S9     = 25;
constexpr int32_t GPR_S10    = 26;
constexpr int32_t GPR_S11    = 27;
constexpr int32_t GPR_T3     = 28;
constexpr int32_t GPR_T4     = 29;
constexpr int32_t GPR_T5     = 30;
constexpr int32_t GPR_T6     = 31;

// Encoding for common instructions
constexpr int32_t EBREAK_INSN_ENC = 0x00100073; 
constexpr int32_t ECALL_INSN_ENC = 0x00000073;
constexpr int32_t SRET_INSN_ENC = 0x10200073;
constexpr int32_t MRET_INSN_ENC = 0x30200073;
constexpr int32_t WFI_INSN_ENC = 0x10500073;

constexpr int32_t C_NOP = 0x0001;
constexpr int32_t C_EBREAK_INSN = 0x9002;

// Register encoding
constexpr int32_t REG_RD_ENC_OFFSET = 7;
constexpr int32_t REG_RS1_ENC_OFFSET = 15;
constexpr int32_t REG_RS2_ENC_OFFSET = 20;
constexpr int32_t REG_ENC_MASK = 0x1f;

constexpr int32_t INSN_BUFF_SIZE = (8 * RISCV_MAX_INSN_SIZE);
typedef std::bitset<INSN_BUFF_SIZE> insnBuf_t;

// Instruction encoding
constexpr int32_t AUIPCOp    = 0x17;
constexpr int32_t BRANCHOp   = 0x63;
constexpr int32_t FLDOp      = 0x07;
constexpr int32_t FSDOp      = 0x27;
constexpr int32_t IMMOp      = 0x13;
constexpr int32_t JALOp      = 0x6f;
constexpr int32_t JALROp     = 0x67;
constexpr int32_t LOADOp     = 0x03;
constexpr int32_t LUIOp      = 0x37;
constexpr int32_t REGOp      = 0x33;
constexpr int32_t STOREOp    = 0x23;

constexpr int32_t ADDFunct7  = 0x00;
constexpr int32_t ANDFunct7  = 0x00;
constexpr int32_t DIVFunct7  = 0x01;
constexpr int32_t MULFunct7  = 0x01;
constexpr int32_t ORFunct7   = 0x00;
constexpr int32_t SLLFunct7  = 0x00;
constexpr int32_t SRAFunct7  = 0x20;
constexpr int32_t SRLFunct7  = 0x00;
constexpr int32_t SUBFunct7  = 0x20;
constexpr int32_t XORFunct7  = 0x00;

constexpr int32_t ADDFunct3  = 0x0;
constexpr int32_t ANDFunct3  = 0x7;
constexpr int32_t BEQFunct3  = 0x0;
constexpr int32_t BGEFunct3  = 0x5;
constexpr int32_t BGEUFunct3 = 0x7;
constexpr int32_t BLTFunct3  = 0x4;
constexpr int32_t BLTUFunct3 = 0x6;
constexpr int32_t BNEFunct3  = 0x1;
constexpr int32_t DIVFunct3  = 0x4;
constexpr int32_t FLDFunct3  = 0x3;
constexpr int32_t FSDFunct3  = 0x3;
constexpr int32_t JALRFunct3 = 0x0;
constexpr int32_t LBFunct3   = 0x0;
constexpr int32_t LBUFunct3  = 0x4;
constexpr int32_t LDFunct3   = 0x3;
constexpr int32_t LHFunct3   = 0x1;
constexpr int32_t LHUFunct3  = 0x5;
constexpr int32_t LWFunct3   = 0x2;
constexpr int32_t LWUFunct3  = 0x6;
constexpr int32_t MULFunct3  = 0x0;
constexpr int32_t ORFunct3   = 0x6;
constexpr int32_t SBFunct3   = 0x0;
constexpr int32_t SDFunct3   = 0x3;
constexpr int32_t SHFunct3   = 0x1;
constexpr int32_t SLLFunct3  = 0x1;
constexpr int32_t SRAFunct3  = 0x5;
constexpr int32_t SRLFunct3  = 0x5;
constexpr int32_t SUBFunct3  = 0x0;
constexpr int32_t SWFunct3   = 0x2;
constexpr int32_t XORFunct3  = 0x4;

constexpr int32_t B_COND_EQ  = BEQFunct3;
constexpr int32_t B_COND_NE  = BNEFunct3;
constexpr int32_t B_COND_LT  = BLTFunct3;
constexpr int32_t B_COND_GE  = BGEFunct3;
constexpr int32_t B_COND_LTU = BLTUFunct3;
constexpr int32_t B_COND_GEU = BGEUFunct3;

// Implicit immediate shifts

constexpr int32_t BTYPE_IMM_SHIFT = 1;
constexpr int32_t CADDI16SP_IMM_SHIFT = 4;
constexpr int32_t CADDI4SPN_IMM_SHIFT = 2;
constexpr int32_t CBEQZ_IMM_SHIFT            = 1;
constexpr int32_t CBNEZ_IMM_SHIFT            = 1;
constexpr int32_t CFLD_SHIFT                 = 3;
constexpr int32_t CFLDSP_SHIFT               = 3;
constexpr int32_t CFLW_SHIFT                 = 2;
constexpr int32_t CFLWSP_SHIFT               = 2;
constexpr int32_t CFSD_SHIFT                 = 3;
constexpr int32_t CFSDSP_SHIFT               = 3;
constexpr int32_t CFSW_SHIFT                 = 2;
constexpr int32_t CFSWSP_SHIFT               = 2;
constexpr int32_t CJ_IMM_SHIFT               = 1;
constexpr int32_t CLD_SHIFT                  = 3;
constexpr int32_t CLDSP_SHIFT                = 3;
constexpr int32_t CLW_SHIFT                  = 2;
constexpr int32_t CLWSP_SHIFT                = 2;
constexpr int32_t CSD_SHIFT                  = 3;
constexpr int32_t CSDSP_SHIFT                = 3;
constexpr int32_t CSW_SHIFT                  = 2;
constexpr int32_t CSWSP_SHIFT                = 2;
constexpr int32_t JTYPE_IMM_SHIFT = 1;
constexpr int32_t UTYPE_IMM_SHIFT = 12;

// Mask value of immediates
constexpr int32_t BTYPE_IMM_MASK = 0xfff;
constexpr int32_t CADDI16SP_IMM_MASK         = 0x3f;
constexpr int32_t CADDI4SPN_IMM_MASK         = 0xff;
constexpr int32_t CADDI_IMM_MASK             = 0x3f;
constexpr int32_t CANDI_IMM_MASK             = 0x3f;
constexpr int32_t CBEQZ_IMM_MASK             = 0xff;
constexpr int32_t CBNEZ_IMM_MASK             = 0xff;
constexpr int32_t CFLD_MASK                  = 0x1f;
constexpr int32_t CFLDSP_MASK                = 0x3f;
constexpr int32_t CFLW_MASK                  = 0x1f;
constexpr int32_t CFLWSP_MASK                = 0x3f;
constexpr int32_t CFSD_MASK                  = 0x1f;
constexpr int32_t CFSDSP_MASK                = 0x3f;
constexpr int32_t CFSW_MASK                  = 0x1f;
constexpr int32_t CFSWSP_MASK                = 0x3f;
constexpr int32_t CJ_IMM_MASK                = 0x7ff;
constexpr int32_t CLD_MASK                   = 0x1f;
constexpr int32_t CLDSP_MASK                 = 0x3f;
constexpr int32_t CLI_IMM_MASK               = 0x3f;
constexpr int32_t CLW_MASK                   = 0x1f;
constexpr int32_t CLWSP_MASK                 = 0x3f;
constexpr int32_t CSD_MASK                   = 0x1f;
constexpr int32_t CSDSP_MASK                 = 0x3f;
constexpr int32_t CSLLI_IMM_MASK             = 0x3f;
constexpr int32_t CSRAI_IMM_MASK             = 0x3f;
constexpr int32_t CSRLI_IMM_MASK             = 0x3f;
constexpr int32_t CSW_MASK                   = 0x1f;
constexpr int32_t CSWSP_MASK                 = 0x3f;
constexpr int32_t ITYPE_IMM_MASK = 0xfff;
constexpr int32_t JTYPE_IMM_MASK = 0xfffff;
constexpr int32_t STYPE_IMM_MASK = 0xfff;
constexpr int32_t UTYPE_IMM_MASK = 0xfffff;

// Maximum and minimum of immediates
// Note that the min/max values defined here are *implicitly shifted values*, not the encoded value.

constexpr int32_t CADDI16SP_IMM_MAX          = 0x200;
constexpr int32_t CADDI16SP_IMM_MIN          = -0x200;
constexpr int32_t CADDI4SPN_IMM_MAX          = 0x400;
constexpr int32_t CADDI4SPN_IMM_MIN          = 0;
constexpr int32_t CADDI_IMM_MAX              = 0x20;
constexpr int32_t CADDI_IMM_MIN              = -0x20;
constexpr int32_t CANDI_IMM_MAX              = 0x20;
constexpr int32_t CANDI_IMM_MIN              = -0x20;
constexpr int32_t CBEQZ_IMM_MAX              = 0x100;
constexpr int32_t CBEQZ_IMM_MIN              = -0x100;
constexpr int32_t CBNEZ_IMM_MAX              = 0x100;
constexpr int32_t CBNEZ_IMM_MIN              = -0x100;
constexpr int32_t CFLD_IMM_MAX               = 0x100;
constexpr int32_t CFLD_IMM_MIN               = 0x0;
constexpr int32_t CFLDSP_IMM_MAX             = 0x200;
constexpr int32_t CFLDSP_IMM_MIN             = 0x0;
constexpr int32_t CFLW_IMM_MAX               = 0x80;
constexpr int32_t CFLW_IMM_MIN               = 0x0;
constexpr int32_t CFLWSP_IMM_MAX             = 0x100;
constexpr int32_t CFLWSP_IMM_MIN             = 0x0;
constexpr int32_t CFSD_IMM_MAX               = 0x100;
constexpr int32_t CFSD_IMM_MIN               = 0x0;
constexpr int32_t CFSDSP_IMM_MAX             = 0x200;
constexpr int32_t CFSDSP_IMM_MIN             = 0x0;
constexpr int32_t CFSW_IMM_MAX               = 0x80;
constexpr int32_t CFSW_IMM_MIN               = 0x0;
constexpr int32_t CFSWSP_IMM_MAX             = 0x100;
constexpr int32_t CFSWSP_IMM_MIN             = 0x0;
constexpr int32_t CJ_IMM_MAX                 = 0x800;
constexpr int32_t CJ_IMM_MIN                 = -0x800;
constexpr int32_t CLD_IMM_MAX                = 0x100;
constexpr int32_t CLD_IMM_MIN                = 0x0;
constexpr int32_t CLDSP_IMM_MAX              = 0x200;
constexpr int32_t CLDSP_IMM_MIN              = 0x0;
constexpr int32_t CLI_IMM_MAX                = 0x20;
constexpr int32_t CLI_IMM_MIN                = -0x20;
constexpr int32_t CLUI_IMM_MAX1              = 0x20;
constexpr int32_t CLUI_IMM_MAX2              = 0x100000;
constexpr int32_t CLUI_IMM_MIN1              = 0x1;
constexpr int32_t CLUI_IMM_MIN2              = 0xfffe0;
constexpr int32_t CLW_IMM_MAX                = 0x80;
constexpr int32_t CLW_IMM_MIN                = 0x0;
constexpr int32_t CLWSP_IMM_MAX              = 0x100;
constexpr int32_t CLWSP_IMM_MIN              = 0x0;
constexpr int32_t CSD_IMM_MAX                = 0x100;
constexpr int32_t CSD_IMM_MIN                = 0x0;
constexpr int32_t CSDSP_IMM_MAX              = 0x200;
constexpr int32_t CSDSP_IMM_MIN              = 0x0;
constexpr int32_t CSLLI_IMM_MAX              = 0x40;
constexpr int32_t CSLLI_IMM_MIN              = 0x1;
constexpr int32_t CSRAI_IMM_MAX              = 0x40;
constexpr int32_t CSRAI_IMM_MIN              = 0x1;
constexpr int32_t CSRLI_IMM_MAX              = 0x40;
constexpr int32_t CSRLI_IMM_MIN              = 0x1;
constexpr int32_t CSW_IMM_MAX                = 0x80;
constexpr int32_t CSW_IMM_MIN                = 0x0;
constexpr int32_t CSWSP_IMM_MAX              = 0x100;
constexpr int32_t CSWSP_IMM_MIN              = 0x0;
constexpr int64_t BTYPE_IMM_MAX  = 0x1000;
constexpr int64_t BTYPE_IMM_MIN  = -0x1000;
constexpr int64_t ITYPE_IMM_MAX  = 0x800;
constexpr int64_t ITYPE_IMM_MIN  = -0x800;
constexpr int64_t JTYPE_IMM_MAX = 0x1000000; // 21 bits signed (not 20 because imm is shifted 1 bits left)
constexpr int64_t JTYPE_IMM_MIN = -0x1000000; // 21 bits signed (not 20 because imm is shifted 1 bits left)
constexpr int64_t STYPE_IMM_MAX  = 0xfff;
constexpr int64_t STYPE_IMM_MIN  = 0xfff;
constexpr int64_t UTYPE_IMM_MAX  = 0x80000000LL;  // 32 bits signed
constexpr int64_t UTYPE_IMM_MIN  = -0x80000000LL; // 32 bits signed

// RISC-V immediates in jump/branch instructions are scrambled:
// The following arrays store the corresponding indices to reorder the immediates back
const std::vector<int> JAL_REORDER   = {12, 13, 14, 15, 16, 17, 18, 19, 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20};
const std::vector<int> JALR_REORDER  = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
const std::vector<int> B_REORDER1    = {11, 1, 2, 3, 4};
const std::vector<int> B_REORDER2    = {5, 6, 7, 8, 9, 10, 12};
const std::vector<int> CJ_REORDER    = {5, 1, 2, 3, 7, 6, 10, 8, 9, 4, 11};
const std::vector<int> CB_REORDER1   = {5, 1, 2, 6, 7};
const std::vector<int> CB_REORDER2   = {3, 4, 8};


// The following constants are for instruction parsing (not codegen!)
// Auipc Instruction

constexpr insnBuf_t AUIPC_INSN_MASK      = insnBuf_t(0x0000007f);
constexpr insnBuf_t AUIPC_INSN           = insnBuf_t(0x00000017);
constexpr insnBuf_t AUIPC_IMM_MASK       = insnBuf_t(0xfffff000);
constexpr insnBuf_t AUIPC_REG_MASK       = insnBuf_t(0x00000f80);

constexpr int AUIPC_REG_SHIFT            = 7;

// Jump/Branch instructions

constexpr insnBuf_t J_INSN_MASK      = insnBuf_t(0x0000007f);
constexpr insnBuf_t B_INSN_MASK      = insnBuf_t(0x0000007f);
constexpr insnBuf_t CJ_INSN_MASK     = insnBuf_t(0xe003);
constexpr insnBuf_t CJR_INSN_MASK    = insnBuf_t(0xf003);
constexpr insnBuf_t CB_INSN_MASK     = insnBuf_t(0xe003);

constexpr insnBuf_t B_INSNS          = insnBuf_t(0x00000063);
constexpr insnBuf_t JALR_INSN        = insnBuf_t(0x00000067);
constexpr insnBuf_t JAL_INSN         = insnBuf_t(0x0000006f);
constexpr insnBuf_t CBEQZ_INSN       = insnBuf_t(0xc001);
constexpr insnBuf_t CBNEZ_INSN       = insnBuf_t(0xe001);
constexpr insnBuf_t CJALR_INSN       = insnBuf_t(0x9002);
constexpr insnBuf_t CJAL_INSN        = insnBuf_t(0x2001);
constexpr insnBuf_t CJR_INSN         = insnBuf_t(0x8002);
constexpr insnBuf_t CJ_INSN          = insnBuf_t(0xa001);

// The following are the indices of the immediates' offset
const int JAL_IMM_OFF  = 12;
const int JALR_IMM_OFF = 20;
const int CJ_IMM_OFF   = 2; 

const int B_IMM_OFF1   = 7;
const int B_IMM_OFF2   = 25;
const int CB_IMM_OFF1  = 2;
const int CB_IMM_OFF2  = 10;

// Register masks and shifts for jump/branch instructions
constexpr insnBuf_t B_COND_MASK   = insnBuf_t(0x00007000);
constexpr insnBuf_t B_REG1_MASK   = insnBuf_t(0x000f8000);
constexpr insnBuf_t B_REG2_MASK   = insnBuf_t(0x01f00000);
constexpr insnBuf_t CB_REG1_MASK  = insnBuf_t(0x0380);
constexpr insnBuf_t JALR_REG_MASK = insnBuf_t(0x000f8000);
constexpr insnBuf_t J_LNK_MASK    = insnBuf_t(0x00000f80);
constexpr insnBuf_t CJR_REG_MASK  = insnBuf_t(0x0f80);
constexpr int B_COND_SHIFT        = 12;
constexpr int B_REG1_SHIFT        = 15;
constexpr int B_REG2_SHIFT        = 20;
constexpr int CB_REG1_SHIFT       = 7;
constexpr int CB_REG1_ADD         = 8;
constexpr int JALR_REG_SHIFT      = 15;
constexpr int J_LNK_SHIFT         = 7;
constexpr int CJR_REG_SHIFT       = 7;

// Atomic Instructions
constexpr insnBuf_t A_INSN_MASK = insnBuf_t(0x0000007f);

constexpr insnBuf_t A_INSNS     = insnBuf_t(0x0000002f);
constexpr insnBuf_t A_OP_MASK   = insnBuf_t(0xf8000000);
constexpr insnBuf_t A_OP_LR     = insnBuf_t(0x10000000);
constexpr insnBuf_t A_OP_SC     = insnBuf_t(0x18000000);

#define INSN_BUFF_SET(I, s, e, v)    ((I).setInsnBuf((s), (e - s + 1), (v)))

typedef union {
    unsigned char byte[RISCV_MAX_INSN_SIZE];
    rvMaxInsn_t raw;
} instructUnion;

typedef instructUnion codeBuf_t;

#define maxGPR 32
#define maxFPR 32

class DYNINST_EXPORT instruction {
private:
    // Due to the way codegen.C works, codeBuf_t should be a fixed size.
    // Therefore, we write opcodes to our own instruction buffer `insn_buff` instead.
    // Then, whever we generate the instruction, we call `flushInsnBuffer` to flush the
    // instruction buffer into the 2-byte code buffer `code_buff` short-by-short.

    codeBuf_t insn_;

public:
    instruction(): insn_() {}
    instruction(rvMaxInsn_t raw) {
        insn_.raw = raw;
    }
    instruction(const void *ptr) {
        insn_ = *((const instructUnion *)ptr);
    }
    instruction(const void *ptr, bool): instruction(ptr) {}

    instruction(const instruction &insn) : insn_(insn.insn_) {}
    instruction(codeBuf_t &insn) : insn_(insn) {}

    void clear() { 
        insn_ = instructUnion();
        insn_buff.reset();
    }
    void setInsnBuf(unsigned int pos, unsigned int len, unsigned int value) {
        std::bitset<INSN_BUFF_SIZE> bits(value);
        for (size_t i = 0; i < len; i++) {
            insn_buff.set(pos + i, bits[i]);
        }
    }

    void flushInsnBuff() {
        insn_.raw = static_cast<rvMaxInsn_t>(insn_buff.to_ulong());
    }

    bool isRVC() const {
        return !(insn_buff.test(0) && insn_buff.test(1));
    }

    unsigned size() { return isRVC() ? RVC_INSN_SIZE : RV_INSN_SIZE; }

    // return a pointer to the instruction
    const unsigned char *ptr() const { return (const unsigned char *)&insn_; }

    static bool isAligned(Dyninst::Address addr) {
        return !(addr & 0x1);
    }

    unsigned getTargetReg() const;
    signed long signExtend(unsigned long i, unsigned int pos);
    Dyninst::Address getTarget(Dyninst::Address addr) const;

    bool isBranchReg() const;
    bool isBranchOffset() const;
    bool isUncondBranch() const;
    bool isCondBranch() const;
    bool getUsedRegs(std::vector<int> &regs);
    bool isCall() const;
    unsigned getLinkReg() const;
    unsigned getBranchTargetReg() const;
    Dyninst::Address getBranchOffset() const;
    unsigned getCondBranchOp() const;
    unsigned getCondBranchReg1() const;
    unsigned getCondBranchReg2() const;
    bool isAtomic() const;
    bool isAtomicMemOp() const;
    bool isAtomicLoad() const;
    bool isAtomicStore() const;
    bool isAuipc() const;
    Dyninst::Address getAuipcOffset() const;
    unsigned getAuipcReg() const;
};

}
//end of NS_riscv64

#endif
