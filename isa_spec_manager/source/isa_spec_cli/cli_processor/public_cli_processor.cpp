/*
 * Copyright (c) 2024 Advanced Micro Devices, Inc. All rights reserved.
 */
#include "public_cli_processor.h"

// C++ libraries.
#include <string>
#include <sstream>

// Local libraries.
#include "amdisa/isa_decoder.h"

// Third party libraries.
#include "cxxopts.hpp"

// Include CLI command implementations that belong to this CLI.
#include "cli_command_decode_machine_code.h"
#include "cli_command_decode_shader_file.h"
#include "cli_command_generate_inst_desc.h"
#include "cli_command_get_inst_info.h"
#include "cli_command_print_help.h"
#include "cli_command_read_xml.h"

namespace amdisa
{
    // List of options for this CLI processor.
    // Argument to get help message.
    static const char* kArgHelp       = "help";
    static const char* kArgHelpMsg    = "Print help.";
    static const char  kArgHelp_short = 'h';

    // Input XML file.
    static const char* kArgInputXml       = "xml";
    static const char* kArgInputXmlMsg    = "Path to input XML file.";
    static const char  kArgInputXml_short = 'x';

    // Shader Decode Output XML file.
    static const char* kArgOutputXml       = "shader_output_xml";
    static const char* kArgOutputXmlMsg    = "Path to output XML file generated by shader decoding.";
    static const char  kArgOutputXml_short = 'e';

    // Decode the machine code into the instruction
    static const char* kArgDecodeBits       = "decode_bits";
    static const char* kArgDecodeBitsMsg    = "Decode the given machine code. Should be in hex and a multiple of 32-bits. Examples: -d DD05800001000002, -d DD058000_01000002, -d 76020EF2";
    static const char  kArgDecodeBits_short = 'd';

    // Get instruction information.
    static const char* kArgGetInstructionInfo       = "instruction_info";
    static const char* kArgGetInstructionInfoMsg    = "Get information on the given instruction (Input: instruction name).";
    static const char  kArgGetInstructionInfo_short = 'i';

    // Decode the whole shader disassembly file
    static const char* kArgDecodeShaderFile       = "shader_file";
    static const char* kArgDecodeShaderFileMsg    = "Path to shader disassembly file(sp3 / LLVM)";
    static const char  kArgDecodeShaderFile_short = 'f';

    // Decode the whole shader disassembly file
    static const char* kArgDecodeShaderFileBranchInfo       = "branch_info";
    static const char* kArgDecodeShaderFileBranchInfoMsg    = "Enable direct branch targets information for shader file decoding.";
    static const char  kArgDecodeShaderFileBranchInfo_short = 'b';

    // Decode the whole shader disassembly file
    static const char* kArgDecodeInfoFormat       = "info_format";
    static const char* kArgDecodeInfoFormatMsg    = "Define shader disassembly instruction information XML output format";
    static const char  kArgDecodeInfoFormat_short = 'p';

    // Generate instruction description file.
    static const char* kArgGenInstDescriptions       = "gen_desc";
    static const char* kArgGenInstDescriptionsMsg    = "Path to output file with instruction-to-description mappings.";
    static const char  kArgGenInstDescriptions_short = 'g';

    // Specify the format of generated instruction descriptions.
    static const char* kArgInstDescriptionFormat        = "desc_format";
    static const char* kArgInstDescriptionsFormatMsg    = "Format of the generated instruction descriptions (Ex.: --desc_format=csv)";
    static const char  kArgInstDescriptionsFormat_short = 't';

    // Hiding implementation details of this class.
    struct PublicCliProcessor::PublicCliProcessorImpl
    {
        PublicCliProcessorImpl(IsaDecoder& spec_api)
            : spec_api(spec_api)
        {
        }
        std::vector<std::unique_ptr<ICliCommand>> commands;
        IsaDecoder&                               spec_api;
    };

    PublicCliProcessor::~PublicCliProcessor()
    {
        if (pimpl_ != nullptr)
        {
            delete pimpl_;
            pimpl_ = nullptr;
        }
    }

    void PublicCliProcessor::AppendOptions(cxxopts::Options& options)
    {
        // Form the arguments.
        std::stringstream help_args;
        std::stringstream xml_in_args;
        std::stringstream xml_out_args;
        std::stringstream decode_bits_args;
        std::stringstream get_inst_info_args;
        std::stringstream shader_file_args;
        std::stringstream branch_target_info_args;
        std::stringstream info_format_args;
        std::stringstream gen_inst_desc_args;
        std::stringstream inst_desc_format_args;

        help_args << kArgHelp_short << "," << kArgHelp;
        xml_in_args << kArgInputXml_short << "," << kArgInputXml;
        xml_out_args << kArgOutputXml_short << "," << kArgOutputXml;
        decode_bits_args << kArgDecodeBits_short << "," << kArgDecodeBits;
        get_inst_info_args << kArgGetInstructionInfo_short << "," << kArgGetInstructionInfo;
        shader_file_args << kArgDecodeShaderFile_short << "," << kArgDecodeShaderFile;
        branch_target_info_args << kArgDecodeShaderFileBranchInfo_short << "," << kArgDecodeShaderFileBranchInfo;
        info_format_args << kArgDecodeInfoFormat_short << "," << kArgDecodeInfoFormat;
        gen_inst_desc_args << kArgGenInstDescriptions_short << "," << kArgGenInstDescriptions;
        inst_desc_format_args << kArgInstDescriptionsFormat_short << "," << kArgInstDescriptionFormat;

        options.add_options()(help_args.str(), kArgHelpMsg)(xml_in_args.str(), kArgInputXmlMsg, cxxopts::value<std::string>())(
            decode_bits_args.str(), kArgDecodeBitsMsg, cxxopts::value<std::string>())(
            get_inst_info_args.str(), kArgGetInstructionInfoMsg, cxxopts::value<std::string>())(
            shader_file_args.str(), kArgDecodeShaderFileMsg, cxxopts::value<std::string>())(
            branch_target_info_args.str(), kArgDecodeShaderFileBranchInfoMsg, cxxopts::value<bool>())(
            xml_out_args.str(), kArgOutputXmlMsg, cxxopts::value<std::string>())(
            info_format_args.str(), kArgDecodeInfoFormatMsg, cxxopts::value<std::string>())(
            gen_inst_desc_args.str(), kArgGenInstDescriptionsMsg, cxxopts::value<std::string>())(
            inst_desc_format_args.str(), kArgInstDescriptionsFormatMsg, cxxopts::value<std::string>());

        // Options that could be both in public and internal.
        options.add_options();
    }

    // Creates relevant commands based on the options.
    void PublicCliProcessor::Configure(const cxxopts::ParseResult& arguments, const std::string& cli_help_msg, IsaDecoder& spec_api)
    {
        pimpl_ = new PublicCliProcessorImpl(spec_api);

        // Print help message if user asked.
        if (arguments.count(kArgHelp) > 0)
        {
            pimpl_->commands.push_back(std::make_unique<CliCommandPrintHelp>(cli_help_msg));
        }

        // Read XML.
        if (arguments.count(kArgInputXml) > 0)
        {
            pimpl_->commands.push_back(std::make_unique<CliCommandReadXml>(arguments[kArgInputXml].as<std::string>(), pimpl_->spec_api));
        }

        // Decode binary instruction.
        if (arguments.count(kArgDecodeBits) > 0)
        {
            pimpl_->commands.push_back(std::make_unique<CliCommandDecodeMachineCode>(arguments[kArgDecodeBits].as<std::string>(), pimpl_->spec_api));
        }

        // Request instruction information.
        if (arguments.count(kArgGetInstructionInfo) > 0)
        {
            pimpl_->commands.push_back(
                std::make_unique<CliCommandGetInstInfo>(arguments[kArgGetInstructionInfo].as<std::string>(), pimpl_->spec_api));
        }

        // Decode shader file.
        if (arguments.count(kArgDecodeShaderFile) > 0)
        {
            const std::string shader_file        = arguments[kArgDecodeShaderFile].as<std::string>();
            const bool        branch_target_info = arguments.count(kArgDecodeShaderFileBranchInfo) > 0;

            // Two more options become relevant if we are decoding shader.
            std::string output_xml;
            if (arguments.count(kArgOutputXml) > 0)
            {
                output_xml = arguments[kArgOutputXml].as<std::string>();
            }
            std::string info_format;
            if (arguments.count(kArgDecodeInfoFormat) > 0)
            {
                info_format = arguments[kArgDecodeInfoFormat].as<std::string>();
            }
            pimpl_->commands.push_back(
                std::make_unique<CliCommandDecodeShaderFile>(shader_file, output_xml, info_format, pimpl_->spec_api, branch_target_info));
        }

        // Generate instruction descriptions.
        if (arguments.count(kArgGenInstDescriptions) > 0 && arguments.count(kArgInputXml) > 0)
        {
            std::string desc_format;
            if (arguments.count(kArgInstDescriptionFormat) > 0)
            {
                desc_format = arguments[kArgInstDescriptionFormat].as<std::string>();
            }
            std::string input_xml_path   = arguments[kArgInputXml].as<std::string>();
            std::string output_desc_path = arguments[kArgGenInstDescriptions].as<std::string>();
            pimpl_->commands.push_back(std::make_unique<CliCommandGenerateInstDesc>(output_desc_path, input_xml_path, desc_format));
        }
    }

    void PublicCliProcessor::Run()
    {
        for (const auto& command : pimpl_->commands)
        {
            std::string err_message;
            bool        is_executed = command->Execute(err_message);
            if (!is_executed)
            {
                std::cerr << err_message << std::endl;
            }
        }
    }

}  // namespace amdisa

