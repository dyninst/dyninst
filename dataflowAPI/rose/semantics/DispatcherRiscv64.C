#include "../util/StringUtility.h"
// #include "sage3basic.h"
#include "BaseSemantics2.h"
// #include "Diagnostics.h"
#include "../integerOps.h"
#include "DispatcherRiscv64.h"
#include "SymEvalSemantics.h"

#include "../SgAsmExpression.h"
#include "../conversions.h"

#undef si_value // name pollution from siginfo.h

// RISC-V is not supported by ROSE
// Instead, we're using SAIL (https://github.com/riscv/sail-riscv) for
// instruction semantics

namespace rose {
namespace BinaryAnalysis {
namespace InstructionSemantics2 {

#define XLENBITS 64

#define EXTR(lo, hi) IntegerOps::extract2<B>(lo, hi, raw)

#define PC d->readRegister(d->REG_PC)

/*******************************************************************************************************************************
 *                                      Support functions
 *******************************************************************************************************************************/

static inline size_t asm_type_width(SgAsmType *ty) {
  ASSERT_not_null(ty);
  return ty->get_nBits();
}

/*******************************************************************************************************************************
 *                                      Base Riscv64 instruction processor
 *******************************************************************************************************************************/
namespace Riscv64 {

void InsnProcessor::process(const BaseSemantics::DispatcherPtr &dispatcher_,
                            SgAsmInstruction *insn_) {
  DispatcherRiscv64Ptr dispatcher = DispatcherRiscv64::promote(dispatcher_);
  BaseSemantics::RiscOperatorsPtr operators = dispatcher->get_operators();
  SgAsmRiscv64Instruction *insn = isSgAsmRiscv64Instruction(insn_);
  ASSERT_require(insn != NULL && insn == operators->currentInstruction());
  dispatcher->advanceInstructionPointer(insn);
  SgAsmExpressionPtrList &operands = insn->get_operandList()->get_operands();

  uint32_t raw = 0;
  std::vector<unsigned char> rawBytes = insn->get_raw_bytes();
  for (int idx = 0; idx < rawBytes.size(); idx++) {
    raw |= (rawBytes[idx] << (8 * idx));
  }
  p(dispatcher.get(), operators.get(), insn, operands, raw);

  // Hardwire x0 to 0
  SgAsmDirectRegisterExpression dre0{dispatcher->findRegister("x0", XLENBITS)};
  dispatcher->writeRegister(dre0.get_descriptor(),
                            operators->number_(XLENBITS, 0));
}

void InsnProcessor::assert_args(I insn, A args, size_t nargs) {
  if (args.size() != nargs) {
    std::string mesg = "instruction has incorrect number of args";
    throw BaseSemantics::Exception(mesg, insn);
  }
}

/*******************************************************************************************************************************
 *                                      Helper functions
 *******************************************************************************************************************************/

inline size_t lrsc_width_str(SgAsmRiscv64Instruction *insn) {
  if (insn->get_mnemonic().find(".b") != std::string::npos) {
    return 1;
  } else if (insn->get_mnemonic().find(".h") != std::string::npos) {
    return 2;
  } else if (insn->get_mnemonic().find(".w") != std::string::npos) {
    return 4;
  } else if (insn->get_mnemonic().find(".d") != std::string::npos) {
    return 8;
  } else {
    assert(0 && "Invalid RISC-V lrsc width");
  }
}

inline size_t amo_signed_str(SgAsmRiscv64Instruction *insn) {
  if (insn->get_mnemonic().find("u_") != std::string::npos) {
    return 1;
  } else {
    return 0;
  }
}

inline bool is_c_ext(SgAsmRiscv64Instruction *insn) {
  return insn->get_mnemonic().find(".c") != std::string::npos;
}

inline size_t get_next_pc(SgAsmRiscv64Instruction *insn) {
  return insn->get_address() + insn->get_size();
}

/*******************************************************************************************************************************
 *                                      Functors that handle individual Riscv64
 *instructions kinds
 *******************************************************************************************************************************/
typedef InsnProcessor P;

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=AMO
struct IP_UTYPE : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    BaseSemantics::SValuePtr imm = d->read(args[1], 64, 0);
    SgAsmExpression *rd = args[0];
    enum Riscv64InstructionKind op = insn->get_kind();

    BaseSemantics::SValuePtr off;
    off = d->SignExtend(ops->shiftLeft(imm, ops->number_(64, 12)), 64);
    switch (op) {
    case rose_riscv64_op_lui: {
      d->write(rd, off);
      break;
    }
    case rose_riscv64_op_auipc: {
      d->write(rd, ops->add(PC, off));
      break;
    }
    default: {
      assert(0);
      break;
    }
    };
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=JAL
struct IP_JAL : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    BaseSemantics::SValuePtr imm = d->read(args[1], 64, 0);
    SgAsmExpression *rd = args[0];

    BaseSemantics::SValuePtr link_address;
    link_address = ops->add(PC, ops->number_(64, insn->get_size()));
    d->BranchTo(ops->add(PC, d->SignExtend(imm, 64)));
    d->write(rd, link_address);
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=JALR
struct IP_JALR : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    BaseSemantics::SValuePtr imm = d->read(args[2], 64, 0);
    SgAsmExpression *rs1 = args[1];
    SgAsmExpression *rd = args[0];

    BaseSemantics::SValuePtr link_address;
    BaseSemantics::SValuePtr target;
    link_address = ops->add(PC, ops->number_(64, insn->get_size()));
    target = ops->add(d->read(rs1, 64, 0), d->SignExtend(imm, 64));
    d->BranchTo(ops->concat(ops->extract(target, 1, 63), ops->number_(64, 0)));
    d->write(rd, link_address);
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=BTYPE
struct IP_BTYPE : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    BaseSemantics::SValuePtr imm = d->read(args[2], 64, 0);
    SgAsmExpression *rs2 = args[1];
    SgAsmExpression *rs1 = args[0];
    enum Riscv64InstructionKind op = insn->get_kind();

    BaseSemantics::SValuePtr taken;
    switch (op) {
    case rose_riscv64_op_beq: {
      taken = ops->isEqual(d->read(rs1, 64, 0), d->read(rs2, 64, 0));
      break;
    }
    case rose_riscv64_op_bne: {
      taken = ops->isNotEqual(d->read(rs1, 64, 0), d->read(rs2, 64, 0));
      break;
    }
    case rose_riscv64_op_blt: {
      taken = ops->isSignedLessThan(d->read(rs1, 64, 0), d->read(rs2, 64, 0));
      break;
    }
    case rose_riscv64_op_bge: {
      taken = ops->isSignedGreaterThanOrEqual(d->read(rs1, 64, 0),
                                              d->read(rs2, 64, 0));
      break;
    }
    case rose_riscv64_op_bltu: {
      taken = ops->isUnsignedLessThan(d->read(rs1, 64, 0), d->read(rs2, 64, 0));
      break;
    }
    case rose_riscv64_op_bgeu: {
      taken = ops->isUnsignedGreaterThanOrEqual(d->read(rs1, 64, 0),
                                                d->read(rs2, 64, 0));
      break;
    }
    default: {
      assert(0);
      break;
    }
    };
    d->BranchTo(ops->ite(taken, ops->add(PC, d->SignExtend(imm, 64)), PC));
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=ITYPE
struct IP_ITYPE : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    BaseSemantics::SValuePtr imm = d->read(args[2], 64, 0);
    SgAsmExpression *rs1 = args[1];
    SgAsmExpression *rd = args[0];
    enum Riscv64InstructionKind op = insn->get_kind();

    BaseSemantics::SValuePtr immext;
    immext = d->SignExtend(imm, 64);
    switch (op) {
    case rose_riscv64_op_addi: {
      d->write(rd, ops->add(d->read(rs1, 64, 0), immext));
      break;
    }
    case rose_riscv64_op_slti: {
      d->write(rd, d->ZeroExtend(
                       ops->isSignedLessThan(d->read(rs1, 64, 0), immext), 64));
      break;
    }
    case rose_riscv64_op_sltiu: {
      d->write(rd,
               d->ZeroExtend(
                   ops->isUnsignedLessThan(d->read(rs1, 64, 0), immext), 64));
      break;
    }
    case rose_riscv64_op_andi: {
      d->write(rd, ops->and_(d->read(rs1, 64, 0), immext));
      break;
    }
    case rose_riscv64_op_ori: {
      d->write(rd, ops->or_(d->read(rs1, 64, 0), immext));
      break;
    }
    case rose_riscv64_op_xori: {
      d->write(rd, ops->xor_(d->read(rs1, 64, 0), immext));
      break;
    }
    default: {
      assert(0);
      break;
    }
    };
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=SHIFTIOP
struct IP_SHIFTIOP : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    BaseSemantics::SValuePtr shamt = d->read(args[2], 64, 0);
    SgAsmExpression *rs1 = args[1];
    SgAsmExpression *rd = args[0];
    enum Riscv64InstructionKind op = insn->get_kind();

    shamt = ops->extract(shamt, 0, 5);
    switch (op) {
    case rose_riscv64_op_slli: {
      d->write(rd, ops->shiftLeft(d->read(rs1, 64, 0), shamt));
      break;
    }
    case rose_riscv64_op_srli: {
      d->write(rd, ops->shiftRight(d->read(rs1, 64, 0), shamt));
      break;
    }
    case rose_riscv64_op_srai: {
      d->write(rd, ops->shiftRightArithmetic(d->read(rs1, 64, 0), shamt));
      break;
    }
    default: {
      assert(0);
      break;
    }
    };
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=RTYPE
struct IP_RTYPE : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    SgAsmExpression *rs2 = args[2];
    SgAsmExpression *rs1 = args[1];
    SgAsmExpression *rd = args[0];
    enum Riscv64InstructionKind op = insn->get_kind();

    switch (op) {
    case rose_riscv64_op_add: {
      d->write(rd, ops->add(d->read(rs1, 64, 0), d->read(rs2, 64, 0)));
      break;
    }
    case rose_riscv64_op_slt: {
      d->write(rd, d->ZeroExtend(ops->isSignedLessThan(d->read(rs1, 64, 0),
                                                       d->read(rs2, 64, 0)),
                                 64));
      break;
    }
    case rose_riscv64_op_sltu: {
      d->write(rd, d->ZeroExtend(ops->isUnsignedLessThan(d->read(rs1, 64, 0),
                                                         d->read(rs2, 64, 0)),
                                 64));
      break;
    }
    case rose_riscv64_op_and: {
      d->write(rd, ops->and_(d->read(rs1, 64, 0), d->read(rs2, 64, 0)));
      break;
    }
    case rose_riscv64_op_or: {
      d->write(rd, ops->or_(d->read(rs1, 64, 0), d->read(rs2, 64, 0)));
      break;
    }
    case rose_riscv64_op_xor: {
      d->write(rd, ops->xor_(d->read(rs1, 64, 0), d->read(rs2, 64, 0)));
      break;
    }
    case rose_riscv64_op_sll: {
      d->write(rd, ops->shiftLeft(d->read(rs1, 64, 0),
                                  ops->extract(d->read(rs2, 64, 0), 0, 5)));
      break;
    }
    case rose_riscv64_op_srl: {
      d->write(rd, ops->shiftRight(d->read(rs1, 64, 0),
                                   ops->extract(d->read(rs2, 64, 0), 0, 5)));
      break;
    }
    case rose_riscv64_op_sub: {
      d->write(rd, ops->subtract(d->read(rs1, 64, 0), d->read(rs2, 64, 0)));
      break;
    }
    case rose_riscv64_op_sra: {
      d->write(rd, ops->shiftRightArithmetic(
                       d->read(rs1, 64, 0),
                       ops->extract(d->read(rs2, 64, 0), 0, 5)));
      break;
    }
    default: {
      assert(0);
      break;
    }
    };
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=LOAD
struct IP_LOAD : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    SgAsmExpression *rs1 = args[1];
    SgAsmExpression *rd = args[0];
    int is_unsigned;
    size_t width;
    switch (insn->get_kind()) {
    case rose_riscv64_op_lb:
      width = 1;
      is_unsigned = 1;
      break;
    case rose_riscv64_op_lbu:
      width = 1;
      is_unsigned = 0;
      break;
    case rose_riscv64_op_lh:
      width = 2;
      is_unsigned = 1;
      break;
    case rose_riscv64_op_lhu:
      width = 2;
      is_unsigned = 0;
      break;
    case rose_riscv64_op_lw:
      width = 4;
      is_unsigned = 1;
      break;
    case rose_riscv64_op_lwu:
      width = 4;
      is_unsigned = 0;
      break;
    case rose_riscv64_op_ld:
      width = 8;
      is_unsigned = 1;
      break;
    default:
      assert(0);
      break;
    }

    /* The offset variable is not used, and this is because effectiveAddress
     * already handles the immediate */

    // BaseSemantics::SValuePtr offset;
    BaseSemantics::SValuePtr tmp;
    BaseSemantics::SValuePtr data;
    // offset = d->SignExtend(imm, 64);
    tmp = d->effectiveAddress(rs1);
    data = d->readMemory(tmp, width);
    d->write(rd, ops->ite(ops->number_(64, is_unsigned),
                          d->SignExtend(data, 64), d->ZeroExtend(data, 64)));
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=STORE
struct IP_STORE : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    SgAsmExpression *rs1 = args[1];
    SgAsmExpression *rs2 = args[0];
    size_t width;
    switch (insn->get_kind()) {
    case rose_riscv64_op_sb:
      width = 1;
      break;
    case rose_riscv64_op_sh:
      width = 2;
      break;
    case rose_riscv64_op_sw:
      width = 4;
      break;
    case rose_riscv64_op_sd:
      width = 8;
      break;
    default:
      assert(0);
    }

    BaseSemantics::SValuePtr offset;
    BaseSemantics::SValuePtr data;
    BaseSemantics::SValuePtr tmp;
    /* The offset variable is not used, and this is because effectiveAddress
     * already handles the immediate */

    // offset = d->SignExtend(imm, 64);
    data =
        ops->extract(d->read(rs2, 64, 0), ops->number_(64, 0),
                     ops->subtract(ops->signedMultiply(ops->number_(64, width),
                                                       ops->number_(64, 8)),
                                   ops->number_(64, 1)));
    tmp = d->effectiveAddress(rs1);
    d->writeMemory(tmp, width, data);
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=ADDIW
struct IP_ADDIW : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    BaseSemantics::SValuePtr imm = d->read(args[2], 64, 0);
    SgAsmExpression *rs1 = args[1];
    SgAsmExpression *rd = args[0];

    BaseSemantics::SValuePtr result;
    result = ops->add(d->read(rs1, 64, 0), d->SignExtend(imm, 64));
    d->write(rd, d->SignExtend(ops->extract(result, 0, 31), 64));
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=RTYPEW
struct IP_RTYPEW : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    SgAsmExpression *rs2 = args[2];
    SgAsmExpression *rs1 = args[1];
    SgAsmExpression *rd = args[0];
    enum Riscv64InstructionKind op = insn->get_kind();

    BaseSemantics::SValuePtr rs1_val;
    BaseSemantics::SValuePtr rs2_val;
    BaseSemantics::SValuePtr result;
    rs1_val = ops->extract(d->read(rs1, 64, 0), 0, 31);
    rs2_val = ops->extract(d->read(rs2, 64, 0), 0, 31);
    switch (op) {
    case rose_riscv64_op_addw: {
      result = ops->add(rs1_val, rs2_val);
      break;
    }
    case rose_riscv64_op_subw: {
      result = ops->subtract(rs1_val, rs2_val);
      break;
    }
    case rose_riscv64_op_sllw: {
      result = ops->shiftLeft(rs1_val, ops->extract(rs2_val, 0, 4));
      break;
    }
    case rose_riscv64_op_srlw: {
      result = ops->shiftRight(rs1_val, ops->extract(rs2_val, 0, 4));
      break;
    }
    case rose_riscv64_op_sraw: {
      result = ops->shiftRightArithmetic(rs1_val, ops->extract(rs2_val, 0, 4));
      break;
    }
    default: {
      assert(0);
      break;
    }
    };
    d->write(rd, d->SignExtend(result, 64));
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=SHIFTIWOP
struct IP_SHIFTIWOP : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    BaseSemantics::SValuePtr shamt = d->read(args[2], 64, 0);
    SgAsmExpression *rs1 = args[1];
    SgAsmExpression *rd = args[0];
    enum Riscv64InstructionKind op = insn->get_kind();

    BaseSemantics::SValuePtr rs1_val;
    BaseSemantics::SValuePtr result;
    rs1_val = ops->extract(d->read(rs1, 64, 0), 0, 31);
    switch (op) {
    case rose_riscv64_op_slliw: {
      result = ops->shiftLeft(rs1_val, shamt);
      break;
    }
    case rose_riscv64_op_srliw: {
      result = ops->shiftRight(rs1_val, shamt);
      break;
    }
    case rose_riscv64_op_sraiw: {
      result = ops->shiftRightArithmetic(rs1_val, shamt);
      break;
    }
    default: {
      assert(0);
      break;
    }
    };
    d->write(rd, d->SignExtend(result, 64));
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=MUL
struct IP_MUL : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    SgAsmExpression *rs2 = args[2];
    SgAsmExpression *rs1 = args[1];
    SgAsmExpression *rd = args[0];
    enum Riscv64InstructionKind op = insn->get_kind();
    bool mul_op_signed_rs1;
    bool mul_op_signed_rs2;
    bool mul_op_high;
    switch (insn->get_kind()) {
    case rose_riscv64_op_mul:
      mul_op_signed_rs1 = 1;
      mul_op_signed_rs2 = 1;
      mul_op_high = 0;
      break;
    case rose_riscv64_op_mulh:
      mul_op_signed_rs1 = 1;
      mul_op_signed_rs2 = 1;
      mul_op_high = 1;
      break;
    case rose_riscv64_op_mulhsu:
      mul_op_signed_rs1 = 1;
      mul_op_signed_rs2 = 0;
      mul_op_high = 1;
      break;
    case rose_riscv64_op_mulhu:
      mul_op_signed_rs1 = 0;
      mul_op_signed_rs2 = 0;
      mul_op_high = 1;
      break;
    default:
      assert(0);
    }

    BaseSemantics::SValuePtr rs1_bits;
    BaseSemantics::SValuePtr rs2_bits;
    BaseSemantics::SValuePtr rs1_int;
    BaseSemantics::SValuePtr rs2_int;
    BaseSemantics::SValuePtr result_wide;
    rs1_bits = d->read(rs1, 64, 0);
    rs2_bits = d->read(rs2, 64, 0);
    rs1_int = ops->ite(ops->number_(64, mul_op_signed_rs1), rs1_bits, rs1_bits);
    rs2_int = ops->ite(ops->number_(64, mul_op_signed_rs2), rs2_bits, rs2_bits);
    result_wide = ops->extract(
        ops->ite(
            ops->and_(ops->boolean_(ops->number_(64, mul_op_signed_rs1)),
                      ops->boolean_(ops->number_(64, mul_op_signed_rs2))),
            ops->signedMultiply(rs1_int, rs2_int),
            ops->ite(
                ops->and_(ops->boolean_(ops->number_(64, mul_op_signed_rs1)),
                          ops->boolean_(ops->invert(
                              ops->number_(64, mul_op_signed_rs2)))),
                d->signedUnsignedMultiply(rs1_int, rs2_int),
                ops->ite(ops->and_(
                             ops->boolean_(ops->number_(64, mul_op_signed_rs1)),
                             ops->boolean_(ops->invert(
                                 ops->number_(64, mul_op_signed_rs2)))),
                         d->signedUnsignedMultiply(rs2_int, rs1_int),
                         ops->unsignedMultiply(rs1_int, rs2_int)))),
        0, 128);
    d->write(rd, ops->ite(ops->number_(64, mul_op_high),
                          ops->extract(result_wide, 64, 127),
                          ops->extract(result_wide, 0, 63)));
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=DIV
struct IP_DIV : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    SgAsmExpression *rs2 = args[2];
    SgAsmExpression *rs1 = args[1];
    SgAsmExpression *rd = args[0];
    bool is_unsigned;
    switch (insn->get_kind()) {
    case rose_riscv64_op_div:
      is_unsigned = 1;
      break;
    case rose_riscv64_op_divu:
      is_unsigned = 0;
      break;
    default:
      assert(0);
    }

    BaseSemantics::SValuePtr rs1_bits;
    BaseSemantics::SValuePtr rs2_bits;
    BaseSemantics::SValuePtr rs1_int;
    BaseSemantics::SValuePtr rs2_int;
    BaseSemantics::SValuePtr quotient;
    rs1_bits = d->read(rs1, 64, 0);
    rs2_bits = d->read(rs2, 64, 0);
    rs1_int = ops->ite(ops->number_(64, is_unsigned), rs1_bits, rs1_bits);
    rs2_int = ops->ite(ops->number_(64, is_unsigned), rs2_bits, rs2_bits);
    quotient = ops->ite(ops->isEqual(rs2_int, ops->number_(64, 0)),
                        ops->number_(64, -1),
                        ops->ite(ops->boolean_(ops->number_(64, is_unsigned)),
                                 ops->signedDivide(rs1_int, rs2_int),
                                 ops->unsignedDivide(rs2_int, rs1_int)));
    quotient = ops->ite(
        ops->and_(ops->boolean_(ops->invert(
                      ops->boolean_(ops->number_(64, is_unsigned)))),
                  ops->boolean_(ops->isSignedGreaterThanOrEqual(
                      quotient, ops->shiftLeft(ops->number_(64, 1),
                                               ops->number_(64, 63))))),
        ops->negate(ops->shiftLeft(ops->number_(64, 1), ops->number_(64, 63))),
        quotient);
    d->write(rd, ops->extract(quotient, 0, 64));
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=REM
struct IP_REM : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    SgAsmExpression *rs2 = args[2];
    SgAsmExpression *rs1 = args[1];
    SgAsmExpression *rd = args[0];
    bool is_unsigned;
    switch (insn->get_kind()) {
    case rose_riscv64_op_rem:
      is_unsigned = 1;
      break;
    case rose_riscv64_op_remu:
      is_unsigned = 0;
      break;
    default:
      assert(0);
    }

    BaseSemantics::SValuePtr rs1_bits;
    BaseSemantics::SValuePtr rs2_bits;
    BaseSemantics::SValuePtr rs1_int;
    BaseSemantics::SValuePtr rs2_int;
    BaseSemantics::SValuePtr remainder;
    rs1_bits = d->read(rs1, 64, 0);
    rs2_bits = d->read(rs2, 64, 0);
    rs1_int = ops->ite(ops->number_(64, is_unsigned), rs1_bits, rs1_bits);
    rs2_int = ops->ite(ops->number_(64, is_unsigned), rs2_bits, rs2_bits);
    remainder = ops->ite(ops->isEqual(rs2_int, ops->number_(64, 0)), rs1_int,
                         ops->ite(ops->boolean_(ops->number_(64, is_unsigned)),
                                  ops->signedModulo(rs1_int, rs2_int),
                                  ops->unsignedModulo(rs2_int, rs1_int)));
    d->write(rd, ops->extract(remainder, 0, 64));
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=MULW
struct IP_MULW : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    SgAsmExpression *rs2 = args[2];
    SgAsmExpression *rs1 = args[1];
    SgAsmExpression *rd = args[0];

    BaseSemantics::SValuePtr rs1_bits;
    BaseSemantics::SValuePtr rs2_bits;
    BaseSemantics::SValuePtr rs1_int;
    BaseSemantics::SValuePtr rs2_int;
    BaseSemantics::SValuePtr result32;
    rs1_bits = ops->extract(d->read(rs1, 64, 0), 0, 31);
    rs2_bits = ops->extract(d->read(rs2, 64, 0), 0, 31);
    rs1_int = rs1_bits;
    rs2_int = rs2_bits;
    result32 = ops->extract(ops->signedMultiply(rs1_int, rs2_int), 0, 32);
    d->write(rd, d->SignExtend(result32, 64));
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=DIVW
struct IP_DIVW : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    SgAsmExpression *rs2 = args[2];
    SgAsmExpression *rs1 = args[1];
    SgAsmExpression *rd = args[0];
    bool is_unsigned;
    switch (insn->get_kind()) {
    case rose_riscv64_op_div:
      is_unsigned = 1;
      break;
    case rose_riscv64_op_divu:
      is_unsigned = 0;
      break;
    default:
      assert(0);
    }

    BaseSemantics::SValuePtr rs1_bits;
    BaseSemantics::SValuePtr rs2_bits;
    BaseSemantics::SValuePtr rs1_int;
    BaseSemantics::SValuePtr rs2_int;
    BaseSemantics::SValuePtr quotient;
    rs1_bits = ops->extract(d->read(rs1, 64, 0), 0, 31);
    rs2_bits = ops->extract(d->read(rs2, 64, 0), 0, 31);
    rs1_int = ops->ite(ops->number_(64, is_unsigned), rs1_bits, rs1_bits);
    rs2_int = ops->ite(ops->number_(64, is_unsigned), rs2_bits, rs2_bits);
    quotient = ops->ite(ops->isEqual(rs2_int, ops->number_(64, 0)),
                        ops->number_(64, -1),
                        ops->ite(ops->boolean_(ops->number_(64, is_unsigned)),
                                 ops->signedDivide(rs1_int, rs2_int),
                                 ops->unsignedDivide(rs2_int, rs1_int)));
    quotient = ops->ite(
        ops->and_(ops->boolean_(ops->invert(
                      ops->boolean_(ops->number_(64, is_unsigned)))),
                  ops->boolean_(ops->isSignedGreaterThanOrEqual(
                      quotient, ops->shiftLeft(ops->number_(64, 1),
                                               ops->number_(64, 31))))),
        ops->negate(ops->shiftLeft(ops->number_(64, 1), ops->number_(64, 31))),
        quotient);
    d->write(rd, d->SignExtend(ops->extract(quotient, 0, 32), 64));
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=REMW
struct IP_REMW : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    SgAsmExpression *rs2 = args[2];
    SgAsmExpression *rs1 = args[1];
    SgAsmExpression *rd = args[0];
    bool is_unsigned;
    switch (insn->get_kind()) {
    case rose_riscv64_op_rem:
      is_unsigned = 1;
      break;
    case rose_riscv64_op_remu:
      is_unsigned = 0;
      break;
    default:
      assert(0);
    }

    BaseSemantics::SValuePtr rs1_bits;
    BaseSemantics::SValuePtr rs2_bits;
    BaseSemantics::SValuePtr rs1_int;
    BaseSemantics::SValuePtr rs2_int;
    BaseSemantics::SValuePtr remainder;
    rs1_bits = ops->extract(d->read(rs1, 64, 0), 0, 31);
    rs2_bits = ops->extract(d->read(rs2, 64, 0), 0, 31);
    rs1_int = ops->ite(ops->number_(64, is_unsigned), rs1_bits, rs1_bits);
    rs2_int = ops->ite(ops->number_(64, is_unsigned), rs2_bits, rs2_bits);
    remainder = ops->ite(ops->isEqual(rs2_int, ops->number_(64, 0)), rs1_int,
                         ops->ite(ops->boolean_(ops->number_(64, is_unsigned)),
                                  ops->signedModulo(rs1_int, rs2_int),
                                  ops->unsignedModulo(rs2_int, rs1_int)));
    d->write(rd, d->SignExtend(ops->extract(remainder, 0, 32), 64));
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=LOADRES
struct IP_LOADRES : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    SgAsmExpression *rs1 = args[1];
    size_t width = lrsc_width_str(insn);
    SgAsmExpression *rd = args[0];

    BaseSemantics::SValuePtr tmp;
    BaseSemantics::SValuePtr data;
    tmp = d->effectiveAddress(rs1);
    data = d->readMemory(tmp, width);
    d->write(rd, d->SignExtend(data, 64));
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=STORECON
struct IP_STORECON : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    SgAsmExpression *rs2 = args[2];
    SgAsmExpression *rs1 = args[1];
    size_t width = lrsc_width_str(insn);
    SgAsmExpression *rd = args[0];

    BaseSemantics::SValuePtr data;
    BaseSemantics::SValuePtr tmp;
    data =
        ops->extract(d->read(rs2, 64, 0), ops->number_(64, 0),
                     ops->subtract(ops->signedMultiply(ops->number_(64, width),
                                                       ops->number_(64, 8)),
                                   ops->number_(64, 1)));
    tmp = d->effectiveAddress(rs1);
    d->writeMemory(tmp, width, data);
    return;
  }
};

// Generated by SAIL to ROSE parser
// SAIL version v0.20
// SAIL-RISCV version: v0.9
// Command: perl json_to_rose.pl --insn-set=AMO
struct IP_AMO : P {
  void p(D d, Ops ops, I insn, A args, B raw) {
    enum Riscv64InstructionKind op = insn->get_kind();
    SgAsmExpression *rs2 = args[1];
    SgAsmExpression *rs1 = args[2];
    size_t width = lrsc_width_str(insn);
    SgAsmExpression *rd = args[0];

    BaseSemantics::SValuePtr vaddr;
    BaseSemantics::SValuePtr addr;
    BaseSemantics::SValuePtr rs2_val;
    BaseSemantics::SValuePtr loaded;
    BaseSemantics::SValuePtr result;
    vaddr = d->effectiveAddress(rs1);
    addr = vaddr;
    rs2_val = ops->ite(ops->isSignedLessThanOrEqual(ops->number_(64, width),
                                                    ops->number_(64, 8)),
                       ops->extract(d->read(rs2, 64, 0), ops->number_(64, 0),
                                    ops->signedMultiply(ops->number_(64, width),
                                                        ops->number_(64, 8))),
                       ops->extract(d->read(rs2, 64, 0), ops->number_(64, 0),
                                    ops->signedMultiply(ops->number_(64, width),
                                                        ops->number_(64, 8))));
    loaded = d->readMemory(addr, width);
    switch (op) {
    case rose_riscv64_op_amoswap_w:
    case rose_riscv64_op_amoswap_w_aq:
    case rose_riscv64_op_amoswap_w_aq_rl:
    case rose_riscv64_op_amoswap_w_rl:
    case rose_riscv64_op_amoswap_d:
    case rose_riscv64_op_amoswap_d_aq:
    case rose_riscv64_op_amoswap_d_aq_rl:
    case rose_riscv64_op_amoswap_d_rl: {
      result = rs2_val;
      break;
    }
    case rose_riscv64_op_amoadd_w:
    case rose_riscv64_op_amoadd_w_aq:
    case rose_riscv64_op_amoadd_w_aq_rl:
    case rose_riscv64_op_amoadd_w_rl:
    case rose_riscv64_op_amoadd_d:
    case rose_riscv64_op_amoadd_d_aq:
    case rose_riscv64_op_amoadd_d_aq_rl:
    case rose_riscv64_op_amoadd_d_rl: {
      result = ops->add(rs2_val, loaded);
      break;
    }
    case rose_riscv64_op_amoxor_w:
    case rose_riscv64_op_amoxor_w_aq:
    case rose_riscv64_op_amoxor_w_aq_rl:
    case rose_riscv64_op_amoxor_w_rl:
    case rose_riscv64_op_amoxor_d:
    case rose_riscv64_op_amoxor_d_aq:
    case rose_riscv64_op_amoxor_d_aq_rl:
    case rose_riscv64_op_amoxor_d_rl: {
      result = ops->xor_(rs2_val, loaded);
      break;
    }
    case rose_riscv64_op_amoand_w:
    case rose_riscv64_op_amoand_w_aq:
    case rose_riscv64_op_amoand_w_aq_rl:
    case rose_riscv64_op_amoand_w_rl:
    case rose_riscv64_op_amoand_d:
    case rose_riscv64_op_amoand_d_aq:
    case rose_riscv64_op_amoand_d_aq_rl:
    case rose_riscv64_op_amoand_d_rl: {
      result = ops->and_(rs2_val, loaded);
      break;
    }
    case rose_riscv64_op_amoor_w:
    case rose_riscv64_op_amoor_w_aq:
    case rose_riscv64_op_amoor_w_aq_rl:
    case rose_riscv64_op_amoor_w_rl:
    case rose_riscv64_op_amoor_d:
    case rose_riscv64_op_amoor_d_aq:
    case rose_riscv64_op_amoor_d_aq_rl:
    case rose_riscv64_op_amoor_d_rl: {
      result = ops->or_(rs2_val, loaded);
      break;
    }
    case rose_riscv64_op_amomin_w:
    case rose_riscv64_op_amomin_w_aq:
    case rose_riscv64_op_amomin_w_aq_rl:
    case rose_riscv64_op_amomin_w_rl:
    case rose_riscv64_op_amomin_d:
    case rose_riscv64_op_amomin_d_aq:
    case rose_riscv64_op_amomin_d_aq_rl:
    case rose_riscv64_op_amomin_d_rl: {
      result =
          ops->ite(ops->isSignedLessThan(rs2_val, loaded), rs2_val, loaded);
      break;
    }
    case rose_riscv64_op_amomax_w:
    case rose_riscv64_op_amomax_w_aq:
    case rose_riscv64_op_amomax_w_aq_rl:
    case rose_riscv64_op_amomax_w_rl:
    case rose_riscv64_op_amomax_d:
    case rose_riscv64_op_amomax_d_aq:
    case rose_riscv64_op_amomax_d_aq_rl:
    case rose_riscv64_op_amomax_d_rl: {
      result =
          ops->ite(ops->isSignedGreaterThan(rs2_val, loaded), rs2_val, loaded);
      break;
    }
    case rose_riscv64_op_amominu_w:
    case rose_riscv64_op_amominu_w_aq:
    case rose_riscv64_op_amominu_w_aq_rl:
    case rose_riscv64_op_amominu_w_rl:
    case rose_riscv64_op_amominu_d:
    case rose_riscv64_op_amominu_d_aq:
    case rose_riscv64_op_amominu_d_aq_rl:
    case rose_riscv64_op_amominu_d_rl: {
      result =
          ops->ite(ops->isUnsignedLessThan(rs2_val, loaded), rs2_val, loaded);
      break;
    }
    case rose_riscv64_op_amomaxu_w: {
    case rose_riscv64_op_amomaxu_w_aq:
    case rose_riscv64_op_amomaxu_w_aq_rl:
    case rose_riscv64_op_amomaxu_w_rl:
    case rose_riscv64_op_amomaxu_d:
    case rose_riscv64_op_amomaxu_d_aq:
    case rose_riscv64_op_amomaxu_d_aq_rl:
    case rose_riscv64_op_amomaxu_d_rl:
      result = ops->ite(ops->isUnsignedGreaterThan(rs2_val, loaded), rs2_val,
                        loaded);
      break;
    }
    /* Currently AMOCAS is not supported in Capstone */

    // case rose_riscv64_op_amocas_w: {
    // case rose_riscv64_op_amocas_w_aq: {
    // case rose_riscv64_op_amocas_w_aq_rl: {
    // case rose_riscv64_op_amocas_w_rl: {
    // case rose_riscv64_op_amocas_d: {
    // case rose_riscv64_op_amocas_d_aq: {
    // case rose_riscv64_op_amocas_d_aq_rl: {
    // case rose_riscv64_op_amocas_d_rl: {
    //    result = rs2_val;
    //    break;
    //}
    default: {
      assert(0);
      break;
    }
      /* Currently AMOCAS is not supported in Capstone */

      // ops->ite(ops->and_(ops->boolean_(ops->isEqual(op,
      // rose_riscv64_op_amocas)), ops->boolean_(ops->isNotEqual(loaded,
      // ops->ite(ops->isSignedLessThanOrEqual(ops->number_(64, width),
      // ops->number_(64, 8)), ops->extract(d->read(rd, 64, 0), ops->number_(64,
      // 0), ops->signedMultiply(ops->number_(64, 8), ops->number_(64, width))),
      // ops->extract(d->read(rd, 64, 0), ops->number_(64, 0),
      // ops->signedMultiply(ops->number_(64, 8), ops->number_(64, width))))))),
      // d->write(rd, ops->ite(ops->isSignedLessThanOrEqual(ops->number_(64,
      // width), ops->number_(64, 8)), d->SignExtend(loaded, 64),
      // d->SignExtend(loaded, 128))), d->writeMemory(addr, width,
      // d->SignExtend(result, ops->signedMultiply(ops->number_(64, 8),
      // ops->number_(64, width)))));
      // d->write(rd, ops->ite(ops->isSignedLessThanOrEqual(ops->number_(64,
      // width), ops->number_(64, 8)), d->SignExtend(loaded, 64),
      // d->SignExtend(loaded, 128)));
      d->writeMemory(addr, width, result);
      d->write(rd, d->SignExtend(loaded, 64));
    };
    return;
  }
};
} // namespace Riscv64

/*******************************************************************************************************************************
 *                                      DispatcherRiscv64
 *******************************************************************************************************************************/

void DispatcherRiscv64::iproc_init() {
  iproc_set(rose_riscv64_op_add, new Riscv64::IP_RTYPE);
  iproc_set(rose_riscv64_op_addi, new Riscv64::IP_ITYPE);
  iproc_set(rose_riscv64_op_addiw, new Riscv64::IP_ADDIW);
  iproc_set(rose_riscv64_op_addw, new Riscv64::IP_RTYPEW);
  iproc_set(rose_riscv64_op_amoadd_d, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoadd_d_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoadd_d_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoadd_d_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoadd_w, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoadd_w_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoadd_w_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoadd_w_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoand_d, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoand_d_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoand_d_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoand_d_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoand_w, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoand_w_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoand_w_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoand_w_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomax_d, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomax_d_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomax_d_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomax_d_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomax_w, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomax_w_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomax_w_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomax_w_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomaxu_d, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomaxu_d_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomaxu_d_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomaxu_d_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomaxu_w, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomaxu_w_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomaxu_w_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomaxu_w_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomin_d, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomin_d_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomin_d_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomin_d_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomin_w, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomin_w_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomin_w_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amomin_w_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amominu_d, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amominu_d_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amominu_d_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amominu_d_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amominu_w, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amominu_w_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amominu_w_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amominu_w_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoor_d, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoor_d_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoor_d_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoor_d_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoor_w, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoor_w_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoor_w_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoor_w_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoswap_d, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoswap_d_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoswap_d_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoswap_d_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoswap_w, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoswap_w_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoswap_w_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoswap_w_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoxor_d, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoxor_d_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoxor_d_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoxor_d_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoxor_w, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoxor_w_aq, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoxor_w_aq_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_amoxor_w_rl, new Riscv64::IP_AMO);
  iproc_set(rose_riscv64_op_and, new Riscv64::IP_RTYPE);
  iproc_set(rose_riscv64_op_andi, new Riscv64::IP_ITYPE);
  iproc_set(rose_riscv64_op_auipc, new Riscv64::IP_UTYPE);
  iproc_set(rose_riscv64_op_beq, new Riscv64::IP_BTYPE);
  iproc_set(rose_riscv64_op_bge, new Riscv64::IP_BTYPE);
  iproc_set(rose_riscv64_op_bgeu, new Riscv64::IP_BTYPE);
  iproc_set(rose_riscv64_op_blt, new Riscv64::IP_BTYPE);
  iproc_set(rose_riscv64_op_bltu, new Riscv64::IP_BTYPE);
  iproc_set(rose_riscv64_op_bne, new Riscv64::IP_BTYPE);
  iproc_set(rose_riscv64_op_div, new Riscv64::IP_DIV);
  iproc_set(rose_riscv64_op_divu, new Riscv64::IP_DIV);
  iproc_set(rose_riscv64_op_divuw, new Riscv64::IP_DIVW);
  iproc_set(rose_riscv64_op_divw, new Riscv64::IP_DIVW);
  iproc_set(rose_riscv64_op_jal, new Riscv64::IP_JAL);
  iproc_set(rose_riscv64_op_jalr, new Riscv64::IP_JALR);
  iproc_set(rose_riscv64_op_lb, new Riscv64::IP_LOAD);
  iproc_set(rose_riscv64_op_lbu, new Riscv64::IP_LOAD);
  iproc_set(rose_riscv64_op_ld, new Riscv64::IP_LOAD);
  iproc_set(rose_riscv64_op_lh, new Riscv64::IP_LOAD);
  iproc_set(rose_riscv64_op_lhu, new Riscv64::IP_LOAD);
  iproc_set(rose_riscv64_op_lr_d, new Riscv64::IP_LOADRES);
  iproc_set(rose_riscv64_op_lr_d_aq, new Riscv64::IP_LOADRES);
  iproc_set(rose_riscv64_op_lr_d_aq_rl, new Riscv64::IP_LOADRES);
  iproc_set(rose_riscv64_op_lr_d_rl, new Riscv64::IP_LOADRES);
  iproc_set(rose_riscv64_op_lr_w, new Riscv64::IP_LOADRES);
  iproc_set(rose_riscv64_op_lr_w_aq, new Riscv64::IP_LOADRES);
  iproc_set(rose_riscv64_op_lr_w_aq_rl, new Riscv64::IP_LOADRES);
  iproc_set(rose_riscv64_op_lr_w_rl, new Riscv64::IP_LOADRES);
  iproc_set(rose_riscv64_op_lui, new Riscv64::IP_UTYPE);
  iproc_set(rose_riscv64_op_lw, new Riscv64::IP_LOAD);
  iproc_set(rose_riscv64_op_lwu, new Riscv64::IP_LOAD);
  iproc_set(rose_riscv64_op_mul, new Riscv64::IP_MUL);
  iproc_set(rose_riscv64_op_mulh, new Riscv64::IP_MUL);
  iproc_set(rose_riscv64_op_mulhsu, new Riscv64::IP_MUL);
  iproc_set(rose_riscv64_op_mulhu, new Riscv64::IP_MUL);
  iproc_set(rose_riscv64_op_mulw, new Riscv64::IP_MULW);
  iproc_set(rose_riscv64_op_or, new Riscv64::IP_RTYPE);
  iproc_set(rose_riscv64_op_ori, new Riscv64::IP_ITYPE);
  iproc_set(rose_riscv64_op_rem, new Riscv64::IP_REM);
  iproc_set(rose_riscv64_op_remu, new Riscv64::IP_REM);
  iproc_set(rose_riscv64_op_remuw, new Riscv64::IP_REMW);
  iproc_set(rose_riscv64_op_remw, new Riscv64::IP_REMW);
  iproc_set(rose_riscv64_op_sb, new Riscv64::IP_STORE);
  iproc_set(rose_riscv64_op_sc_d, new Riscv64::IP_STORECON);
  iproc_set(rose_riscv64_op_sc_d_aq, new Riscv64::IP_STORECON);
  iproc_set(rose_riscv64_op_sc_d_aq_rl, new Riscv64::IP_STORECON);
  iproc_set(rose_riscv64_op_sc_d_rl, new Riscv64::IP_STORECON);
  iproc_set(rose_riscv64_op_sc_w, new Riscv64::IP_STORECON);
  iproc_set(rose_riscv64_op_sc_w_aq, new Riscv64::IP_STORECON);
  iproc_set(rose_riscv64_op_sc_w_aq_rl, new Riscv64::IP_STORECON);
  iproc_set(rose_riscv64_op_sc_w_rl, new Riscv64::IP_STORECON);
  iproc_set(rose_riscv64_op_sd, new Riscv64::IP_STORE);
  iproc_set(rose_riscv64_op_sh, new Riscv64::IP_STORE);
  iproc_set(rose_riscv64_op_sll, new Riscv64::IP_RTYPE);
  iproc_set(rose_riscv64_op_slli, new Riscv64::IP_SHIFTIOP);
  iproc_set(rose_riscv64_op_slliw, new Riscv64::IP_SHIFTIWOP);
  iproc_set(rose_riscv64_op_sllw, new Riscv64::IP_RTYPEW);
  iproc_set(rose_riscv64_op_slt, new Riscv64::IP_RTYPE);
  iproc_set(rose_riscv64_op_slti, new Riscv64::IP_ITYPE);
  iproc_set(rose_riscv64_op_sltiu, new Riscv64::IP_ITYPE);
  iproc_set(rose_riscv64_op_sltu, new Riscv64::IP_RTYPE);
  iproc_set(rose_riscv64_op_sra, new Riscv64::IP_RTYPE);
  iproc_set(rose_riscv64_op_srai, new Riscv64::IP_SHIFTIOP);
  iproc_set(rose_riscv64_op_sraiw, new Riscv64::IP_SHIFTIWOP);
  iproc_set(rose_riscv64_op_sraw, new Riscv64::IP_RTYPEW);
  iproc_set(rose_riscv64_op_srl, new Riscv64::IP_RTYPE);
  iproc_set(rose_riscv64_op_srli, new Riscv64::IP_SHIFTIOP);
  iproc_set(rose_riscv64_op_srliw, new Riscv64::IP_SHIFTIWOP);
  iproc_set(rose_riscv64_op_srlw, new Riscv64::IP_RTYPEW);
  iproc_set(rose_riscv64_op_sub, new Riscv64::IP_RTYPE);
  iproc_set(rose_riscv64_op_subw, new Riscv64::IP_RTYPEW);
  iproc_set(rose_riscv64_op_sw, new Riscv64::IP_STORE);
  iproc_set(rose_riscv64_op_xor, new Riscv64::IP_RTYPE);
  iproc_set(rose_riscv64_op_xori, new Riscv64::IP_ITYPE);
}

void DispatcherRiscv64::regcache_init() {
  if (regdict) {
    REG_PC = findRegister("pc", 64);
    REG_RA = findRegister("x1", 64);
    REG_SP = findRegister("x2", 64);
  }
}

void DispatcherRiscv64::memory_init() {
  if (BaseSemantics::StatePtr state = currentState()) {
    if (BaseSemantics::MemoryStatePtr memory = state->memoryState()) {
      switch (memory->get_byteOrder()) {
      case ByteOrder::ORDER_LSB:
        break;
      case ByteOrder::ORDER_MSB:
        break;
      case ByteOrder::ORDER_UNSPECIFIED:
        memory->set_byteOrder(ByteOrder::ORDER_LSB);
        break;
      }
    }
  }
}

RegisterDescriptor DispatcherRiscv64::instructionPointerRegister() const {
  return REG_PC;
}

RegisterDescriptor DispatcherRiscv64::stackPointerRegister() const {
  return REG_SP;
}

static bool isStatusRegister(const RegisterDescriptor &reg) {
  assert(0 && "RISC-V does not have status registers");
  return false;
}

RegisterDictionary::RegisterDescriptors
DispatcherRiscv64::get_usual_registers() const {
  RegisterDictionary::RegisterDescriptors registers =
      regdict->get_largest_registers();
  registers.erase(
      std::remove_if(registers.begin(), registers.end(), isStatusRegister),
      registers.end());
  BOOST_FOREACH (const RegisterDescriptor &reg,
                 regdict->get_smallest_registers()) {
    if (isStatusRegister(reg))
      registers.push_back(reg);
  }
  return registers;
}

void DispatcherRiscv64::set_register_dictionary(
    const RegisterDictionary *regdict) {
  BaseSemantics::Dispatcher::set_register_dictionary(regdict);
  regcache_init();
}

BaseSemantics::SValuePtr
DispatcherRiscv64::isZero(const BaseSemantics::SValuePtr &value) {
  return operators->equalToZero(value);
}

void DispatcherRiscv64::BranchTo(const BaseSemantics::SValuePtr &target) {
  ASSERT_require(target != NULL);
  writeRegister(REG_PC, operators->extract(target, 0, 64));
}

BaseSemantics::SValuePtr
DispatcherRiscv64::SignExtend(const BaseSemantics::SValuePtr &expr,
                              size_t newsize) {
  ASSERT_require(newsize > 0);
  return operators->signExtend(expr, newsize);
}

BaseSemantics::SValuePtr
DispatcherRiscv64::ZeroExtend(const BaseSemantics::SValuePtr &expr,
                              size_t newsize) {
  ASSERT_require(newsize > 0);
  return operators->unsignedExtend(expr, newsize);
}

BaseSemantics::SValuePtr
DispatcherRiscv64::Replicate(const BaseSemantics::SValuePtr &expr) {
  ASSERT_not_null(expr);
  ASSERT_always_require(64 % expr->get_width() == 0);

  int blocknums = 64 / expr->get_width();
  BaseSemantics::SValuePtr ret = expr;
  for (int idx = 0; idx < blocknums; idx++) {
    ret = operators->or_(
        ret, operators->shiftLeft(
                 ret, operators->number_(8, expr->get_width() * idx)));
  }

  return ret;
}

BaseSemantics::SValuePtr DispatcherRiscv64::effectiveAddress(SgAsmExpression *e,
                                                             size_t nbits) {
  SgAsmExpression *addressExpression;
  if (SgAsmMemoryReferenceExpression *memoryReferenceExpression =
          isSgAsmMemoryReferenceExpression(e))
    addressExpression = memoryReferenceExpression->get_address();
  else
    addressExpression = e;

  BaseSemantics::SValuePtr retval;

  if (SgAsmRegisterReferenceExpression *rre =
          isSgAsmRegisterReferenceExpression(addressExpression)) {
    const RegisterDescriptor &reg = rre->get_descriptor();
    retval = operators->readRegister(reg);
  } else if (SgAsmBinaryAdd *op = isSgAsmBinaryAdd(addressExpression)) {
    BaseSemantics::SValuePtr lhs = effectiveAddress(op->get_lhs(), nbits);
    BaseSemantics::SValuePtr rhs = effectiveAddress(op->get_rhs(), nbits);
    retval = operators->add(lhs, rhs);
  } else if (SgAsmIntegerValueExpression *ival =
                 isSgAsmIntegerValueExpression(addressExpression)) {
    retval = operators->number_(ival->get_significantBits(), ival->get_value());
  } else if (SgAsmDoubleWordValueExpression *ival =
                 isSgAsmDoubleWordValueExpression(addressExpression)) {
    retval = operators->number_(ival->get_bit_size(), ival->get_value());
  } else if (SgAsmQuadWordValueExpression *ival =
                 isSgAsmQuadWordValueExpression(addressExpression)) {
    retval = operators->number_(ival->get_bit_size(), ival->get_value());
  }

  ASSERT_not_null(retval);
  if (retval->get_width() < nbits) {
    retval = operators->signExtend(retval, nbits);
  } else if (retval->get_width() > nbits) {
    retval = operators->extract(retval, 0, nbits);
  }

  return retval;
}

BaseSemantics::SValuePtr
DispatcherRiscv64::readRegister(const RegisterDescriptor &reg) {
  return operators->readRegister(reg);
}

void DispatcherRiscv64::writeRegister(const RegisterDescriptor &reg,
                                      const BaseSemantics::SValuePtr &value) {
  operators->writeRegister(reg, value);
}

BaseSemantics::SValuePtr DispatcherRiscv64::read(SgAsmExpression *e,
                                                 size_t value_nbits /*=0*/,
                                                 size_t addr_nbits /*=0*/) {
  // Hardwire x0 to value 0
  if (SgAsmDirectRegisterExpression *re = isSgAsmDirectRegisterExpression(e)) {
    const struct RegisterDescriptor &reg = re->get_descriptor();
    if (reg.get_major() == riscv64_regclass_gpr &&
        reg.get_minor() == riscv64_gpr_x0) {
      return operators->number_(64, 0);
    }
  }
  return Dispatcher::read(e, value_nbits, addr_nbits);
}
void DispatcherRiscv64::write(SgAsmExpression *e,
                              const BaseSemantics::SValuePtr &value,
                              size_t addr_nbits /*=0*/) {
  if (SgAsmDirectRegisterExpression *re = isSgAsmDirectRegisterExpression(e)) {
    const struct RegisterDescriptor &reg = re->get_descriptor();
    // Write to x0 means nop
    if (reg.get_major() == riscv64_regclass_gpr &&
        reg.get_minor() == riscv64_gpr_x0) {
      return;
    }
    writeRegister(re->get_descriptor(), value);
  } else {
    Dispatcher::write(e, value, addr_nbits); // defer to super class
  }
}

BaseSemantics::SValuePtr DispatcherRiscv64::fixMemoryAddress(
    const BaseSemantics::SValuePtr &addr) const {
  if (size_t addrWidth = addressWidth()) {
    if (addr->get_width() < addrWidth)
      return operators->signExtend(addr, addrWidth);
    if (addr->get_width() > addrWidth)
      return operators->unsignedExtend(addr, addrWidth);
  }
  return addr;
}

BaseSemantics::SValuePtr
DispatcherRiscv64::readMemory(const BaseSemantics::SValuePtr &addr,
                              size_t readSize) {
  SymEvalSemantics::StateASTPtr state =
      SymEvalSemantics::StateAST::promote(operators->currentState());

  // The second, third and fourth arguments will remain unused
  return state->readMemory(addr, operators->unspecified_(1), NULL, NULL,
                           readSize);
}

void DispatcherRiscv64::writeMemory(const BaseSemantics::SValuePtr &addr,
                                    size_t writeSize,
                                    const BaseSemantics::SValuePtr &data) {
  SymEvalSemantics::StateASTPtr state =
      SymEvalSemantics::StateAST::promote(operators->currentState());

  // The third and fourth arguments will remain unused
  state->writeMemory(addr, data, NULL, NULL, writeSize);
}

SgAsmExpression *DispatcherRiscv64::getWriteBackTarget(SgAsmExpression *expr) {
  SgAsmMemoryReferenceExpression *memoryExpression =
      isSgAsmMemoryReferenceExpression(expr);
  ASSERT_not_null(memoryExpression);

  SgAsmExpression *address = memoryExpression->get_address();
  ASSERT_not_null(address);

  if (isSgAsmBinaryAdd(address)) {
    return isSgAsmBinaryAdd(address)->get_lhs();
  } else {
    SgAsmRegisterReferenceExpression *retval =
        isSgAsmRegisterReferenceExpression(address);
    ASSERT_not_null(retval);

    return retval;
  }
}

BaseSemantics::SValuePtr
DispatcherRiscv64::CountLeadingZeroBits(const BaseSemantics::SValuePtr &expr) {
  size_t len = expr->get_width();

  for (int idx = len - 1; idx >= 0; idx--)
    if (operators->isEqual(operators->extract(expr, len, len + 1),
                           operators->number_(1, 1)))
      return operators->number_(expr->get_width(), len - 1 - idx);

  return operators->number_(expr->get_width(), len);
}

BaseSemantics::SValuePtr
DispatcherRiscv64::CountLeadingSignBits(const BaseSemantics::SValuePtr &expr) {
  size_t len = expr->get_width();
  BaseSemantics::SValuePtr arg = operators->xor_(
      operators->extract(expr, 1, len), operators->extract(expr, 0, len - 1));
  return CountLeadingZeroBits(arg);
}

/* Return the input expression as-is. At this point, it is assumed that any
 * RiscOperators implementation that performs division and passes the result to
 * this method would have already performed the rounding (most likely by using
 * the / operator) to match how integer division is normally performed in C/C++.
 * Of course, this would be invalid for floating point division but that is not
 * currently supported. */
BaseSemantics::SValuePtr
DispatcherRiscv64::RoundTowardsZero(const BaseSemantics::SValuePtr &expr) {
  return expr;
}

BaseSemantics::SValuePtr
DispatcherRiscv64::CountTrailingSignBits(const BaseSemantics::SValuePtr &expr) {
  size_t len = expr->get_width();

  for (int idx = 0; idx < len; idx++)
    if (operators->isEqual(operators->extract(expr, len, len + 1),
                           operators->number_(1, 1)))
      return operators->number_(expr->get_width(), len - 1 - idx);

  return operators->number_(expr->get_width(), len);
}

BaseSemantics::SValuePtr
DispatcherRiscv64::CarrylessMultiply(const BaseSemantics::SValuePtr &a,
                                     const BaseSemantics::SValuePtr &b) {
  size_t len = a->get_width();
  BaseSemantics::SValuePtr result = operators->number_(0, len);

  for (size_t i = 0; i < len; i++) {
    // extract bit i from b
    BaseSemantics::SValuePtr b_bit = operators->extract(b, i, i + 1);

    // if b_bit == 1, XOR (a << i) into result; else XOR 0
    BaseSemantics::SValuePtr term = operators->ite(
        b_bit, operators->shiftLeft(a, operators->number_(len, i)),
        operators->number_(0, len));
    result = operators->xor_(result, term);
  }

  return result;
}

BaseSemantics::SValuePtr
DispatcherRiscv64::CarrylessMultiplyReverse(const BaseSemantics::SValuePtr &a,
                                            const BaseSemantics::SValuePtr &b) {
  size_t len = a->get_width();
  BaseSemantics::SValuePtr result = operators->number_(0, len);

  // iterate from most significant bit down to least
  for (int i = len - 1; i >= 0; i--) {
    BaseSemantics::SValuePtr b_bit = operators->extract(b, i, i + 1);
    BaseSemantics::SValuePtr term = operators->ite(
        b_bit, operators->shiftLeft(a, operators->number_(len, i)),
        operators->number_(0, len));
    result = operators->xor_(result, term);
  }

  return result;
}

BaseSemantics::SValuePtr
DispatcherRiscv64::PopCount(const BaseSemantics::SValuePtr &expr) {
  size_t len = expr->get_width();
  BaseSemantics::SValuePtr count = operators->number_(len, 0);

  for (size_t i = 0; i < len; i++) {
    BaseSemantics::SValuePtr bit = operators->extract(expr, i, i + 1);
    count = operators->add(count, bit);
  }

  return count;
}

BaseSemantics::SValuePtr
DispatcherRiscv64::Brev8(const BaseSemantics::SValuePtr &expr) {
  size_t len = expr->get_width();
  BaseSemantics::SValuePtr result = operators->number_(0, len);

  // iterate over bytes
  for (size_t byte = 0; byte < len; byte += 8) {
    BaseSemantics::SValuePtr byte_val =
        operators->extract(expr, byte, byte + 8);
    BaseSemantics::SValuePtr reversed = operators->number_(8, 0);

    // reverse bits inside the byte
    for (size_t i = 0; i < 8; i++) {
      BaseSemantics::SValuePtr bit = operators->extract(byte_val, i, i + 1);
      reversed = operators->or_(
          reversed, operators->shiftLeft(bit, operators->number_(8, 7 - i)));
    }

    // insert reversed byte back into result
    result = operators->or_(
        result, operators->shiftLeft(reversed, operators->number_(len, byte)));
  }

  return result;
}

BaseSemantics::SValuePtr
DispatcherRiscv64::Rev8(const BaseSemantics::SValuePtr &expr) {
  size_t len = expr->get_width();
  size_t num_bytes = len / 8;
  BaseSemantics::SValuePtr result = operators->number_(0, len);

  for (size_t i = 0; i < num_bytes; i++) {
    BaseSemantics::SValuePtr byte =
        operators->extract(expr, i * 8, (i + 1) * 8);
    result = operators->or_(
        result, operators->shiftLeft(
                    byte, operators->number_(len, (num_bytes - 1 - i) * 8)));
  }

  return result;
}

BaseSemantics::SValuePtr
DispatcherRiscv64::Log2(const BaseSemantics::SValuePtr &expr) {
  size_t len = expr->get_width();
  BaseSemantics::SValuePtr result = operators->number_(len, 0);

  // Scan from MSB to LSB
  for (int i = len - 1; i >= 0; i--) {
    BaseSemantics::SValuePtr bit = operators->extract(expr, i, i + 1);

    // If bit is 1 and result is still 0, set result = i
    result = operators->ite(
        operators->and_(bit,
                        operators->isEqual(result, operators->number_(len, 0))),
        operators->number_(len, i), result);
  }

  return result;
}

BaseSemantics::SValuePtr
DispatcherRiscv64::signedUnsignedMultiply(const BaseSemantics::SValuePtr &a,
                                          const BaseSemantics::SValuePtr &b) {
  // Symbolically, the result of signed(a) * unsigned(b) is
  //   unsigned_multiply(|a|, b) with proper signednes added
  // Thus, the following sequence is equivalent to signed(a) * unsigned(b):
  //   sign = a >> (XLEN-1)
  //   |a| = (a ^ sign) - sign
  //   result = (mul(|a|, b) ^ sign) - sign

  BaseSemantics::SValuePtr sign = operators->shiftRightArithmetic(
      a, operators->number_(XLENBITS, XLENBITS - 1));
  BaseSemantics::SValuePtr absA =
      operators->subtract(operators->xor_(a, sign), sign);
  BaseSemantics::SValuePtr result = operators->subtract(
      operators->xor_(operators->unsignedMultiply(absA, b), sign), sign);
  return result;
}
} // namespace InstructionSemantics2
} // namespace BinaryAnalysis
} // namespace rose

// using namespace rose::Diagnostics;
