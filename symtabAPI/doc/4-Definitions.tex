\section{Definitions and Basic Types}

The following definitions and basic types are referenced throughout the rest of this document.

\subsection{Definitions}

\begin{description}
\item[Offset] Offsets represent an address relative to the start address(base) of the object file. For executables, the Offset represents an absolute address.
The following definitions deal with the symbol table interface.
\item[Object File] An object file is the representation of code that a compiler or assembler generates by processing a source code file. It represents .o's, a.out's and shared libraries.
\item[Region] A region represents a contiguous area of the file that contains executable code or readable data; for example, an ELF section.
\item[Symbol] A symbol represents an entry in the symbol table, and may identify a function, variable or other structure within the file.
\item[Function] A function represents a code object within the file represented by one or more symbols.
\item[Variable] A variable represents a data object within the file represented by one or more symbols.
\item[Module] A module represents a particular source file in cases where multiple files were compiled into a single binary object; if this information is not present, or if the binary object is a shared library, we use a single default module.
\item[Archive] An archive represents a collection of binary objects stored in a single file (e.g., a static archive).
\item[Relocations] These provide the necessary information for inter-object references between two object files.
\item[Exception Blocks] These contain the information necessary for run-time exception handling
The following definitions deal with members of the Symbol class.
\item[Mangled Name] A mangled name for a symbol provides a way of encoding additional information about a function, structure, class or another data type in a symbol name.
It is a technique used to produce unique names for programming entities in many modern programming languages.
For example, in \verb!C++! the method \emph{foo} of class C with signature \emph{int C::foo(int, int)} has a mangled name \emph{\_ZN1C3fooEii} when using the Itanium \verb!C++! ABI (used by all platforms except Windows).

Mangled names may also optionally include a sequence of clone suffixes (begins with `.'), and a version suffix (begins with `@') in that order.
A clone sequence begins with a `.' and indicates a compiler synthesised function (or part thereof) derived from the function without the suffix.
Multiple clone suffixes may exist if a clone is created from another clone.
The structure of clone suffixes is `.\emph{clone\_name}' followed by an optional sequence of `.\emph{<digits>}'.
An older style format exists without the `.\emph{clone\_name}'.
The version suffix is used to support multiple versions of a symbol by the dynamic linker.
\item[Pretty Name] A pretty name for a symbol is the demangled user-level symbolic name without type information for the function parameters and return types.
Any version suffix is removed before demangling and is not included in the pretty name.
For non-mangled names, the pretty name is the versionless name.
Otherwise the the demangler result is returned with any function clone suffixes appended.
For example, a symbol with a mangled name \emph{\_ZN1C3fooEii} for the method \emph{int C::foo(int, int)} has a pretty name \emph{C::foo}.
While \emph{\_ZN1C3fooEii.clone.0@VER\_1} has a pretty name \emph{C::foo.clone.0}.
The pretty name without clone suffixes can be obtained by running the command line tool \code{c++filt -i -p \emph{name}}, or using the libiberty library function \code{cplus\_demangle(\emph{name}, DMGL\_AUTO | DMGL\_ANSI)}.
\item[Typed Name] A typed name for a symbol is the demangled user-level symbolic name including type information for the function parameters.
Typically, but not always, function return type information is not included.
Any version suffix is removed before demangling and is not included in the typed name.
For non-mangled names, the typed name is the versionless name.
Otherwise the the demangler result is returned.
Clone suffixes are part of the typed name.
For example, a symbol with a mangled name \emph{\_ZN1C3fooEii} for the method \emph{int C::foo(int, int)} has a typed name \emph{C::foo(int, int)}.
While \emph{\_ZN1C3fooEii.clone.0@VER\_1} has a pretty name \emph{C::foo(int, int) [clone .clone.0]}.
The typed name can be obtained by running the command line tool \code{c++filt -i \emph{name}}, or using the libiberty library function \code{cplus\_demangle(\emph{name}, DMGL\_AUTO | DMGL\_ANSI | DMGL\_PARAMS)}.
\item[Symbol Linkage] The symbol linkage for a symbol gives information on the visibility (binding) of this symbol, whether it is visible only in the object file where it is defined (local), if it is visible to all the object files that are being linked (global), or if its a weak alias to a global symbol.
\item[Symbol Type] Symbol type for a symbol represents the category of symbols to which it belongs. It can be a function symbol or a variable symbol or a module symbol.
The following definitions deal with the type and the local variable interface.
\item[Type] A type represents the data type of a variable or a parameter. This can represent language pre-defined types (e.g. int, float), pre-defined types in the object (e.g., structures or unions), or user-defined types.
\item[Local Variable] A local variable represents a variable that has been declared within the scope of a sub-routine or a parameter to a sub-routine.
\end{description}

\subsection{Basic Types}

\begin{apient}
typedef unsigned long Offset
\end{apient}
\apidesc{An integer value that contains an offset from base address of the object file.}
\begin{apient}
typedef int typeId_t
\end{apient}
\apidesc{A unique handle for identifying a type. Each of types is assigned a globally unique ID. This way it is easier to identify any data type of a variable or a parameter.}
\begin{apient}
typedef ... PID
\end{apient}
\apidesc{A handle for identifying a process that is used by the dynamic components of SymtabAPI. On UNIX platforms PID is a int, on Windows it is a HANDLE that refers to a process.}
\begin{apient}
typedef unsigned long Address
\end{apient}
\apidesc{An integer value that represents an address in a process. This is used by the dynamic components of SymtabAPI.}
